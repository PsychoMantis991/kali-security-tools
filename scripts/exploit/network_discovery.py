#!/usr/bin/env python3

import logging
import socket
import struct
import ipaddress
import netifaces
import scapy.all as scapy
from typing import Dict, List
from pymetasploit3.msfrpc import MsfRpcClient

logger = logging.getLogger(__name__)

class NetworkDiscovery:
    def __init__(self, msf_client: MsfRpcClient, config: Dict):
        """Inicializa el módulo de descubrimiento de red"""
        self.msf_client = msf_client
        self.config = config
    
    async def discover_networks(self, session_id: str) -> List[str]:
        """Descubre redes desde una sesión establecida"""
        networks = []
        
        try:
            if not self.msf_client or not self.config.get("pivoting", {}).get("discover_new_networks", False):
                return networks
            
            # Obtener información de la sesión
            session = self.msf_client.sessions.session(session_id)
            if not session:
                return networks
            
            # Ejecutar comandos según el tipo de sesión
            if session.type == "meterpreter":
                # Obtener interfaces de red
                interfaces = session.net.config.interfaces
                for interface in interfaces:
                    if interface.get("ip"):
                        network = self._get_network_from_ip(interface["ip"], interface.get("netmask", "255.255.255.0"))
                        if network and network not in networks:
                            networks.append(network)
            
            elif session.type == "shell":
                # Ejecutar comandos para obtener interfaces
                if "windows" in session.platform:
                    cmd = "ipconfig"
                else:
                    cmd = "ifconfig"
                
                output = session.shell.write(cmd)
                networks.extend(self._parse_network_info(output))
        
        except Exception as e:
            logger.error(f"Error al descubrir redes: {str(e)}")
        
        return networks
    
    def _get_network_from_ip(self, ip: str, netmask: str) -> str:
        """Calcula la red a partir de una IP y máscara"""
        try:
            network = ipaddress.IPv4Network(f"{ip}/{netmask}", strict=False)
            return str(network.network_address) + "/" + str(network.prefixlen)
        except:
            return None
    
    def _parse_network_info(self, output: str) -> List[str]:
        """Parsea la salida de comandos de red para extraer redes"""
        networks = []
        try:
            # Buscar patrones de IP y máscara
            import re
            ip_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
            mask_pattern = r"(?:255\.255\.255\.0|255\.255\.0\.0|255\.0\.0\.0)"
            
            ips = re.findall(ip_pattern, output)
            masks = re.findall(mask_pattern, output)
            
            for ip, mask in zip(ips, masks):
                network = self._get_network_from_ip(ip, mask)
                if network and network not in networks:
                    networks.append(network)
        except:
            pass
        return networks
    
    def scan_network(self, network: str) -> Dict:
        """Escanea una red en busca de hosts activos y servicios"""
        results = {
            "network": network,
            "hosts": [],
            "services": {}
        }
        
        try:
            # Configurar opciones de escaneo
            scan_config = self.config.get("network_discovery", {})
            ping_methods = scan_config.get("ping_methods", ["icmp_ping"])
            port_scan_methods = scan_config.get("port_scan_methods", ["tcp_connect"])
            common_ports = scan_config.get("common_ports", [21, 22, 23, 80, 443, 445])
            
            # Obtener lista de hosts en la red
            network_obj = ipaddress.ip_network(network)
            hosts = list(network_obj.hosts())
            
            # Escanear cada host
            for host in hosts:
                host_str = str(host)
                if self._is_host_alive(host_str, ping_methods):
                    host_info = {
                        "ip": host_str,
                        "services": self._scan_ports(host_str, common_ports, port_scan_methods)
                    }
                    results["hosts"].append(host_info)
        
        except Exception as e:
            logger.error(f"Error al escanear red {network}: {str(e)}")
        
        return results
    
    def _is_host_alive(self, host: str, methods: List[str]) -> bool:
        """Verifica si un host está activo usando diferentes métodos"""
        try:
            for method in methods:
                if method == "icmp_ping":
                    if self._icmp_ping(host):
                        return True
                elif method == "tcp_ping":
                    if self._tcp_ping(host):
                        return True
                elif method == "udp_ping":
                    if self._udp_ping(host):
                        return True
        except:
            pass
        return False
    
    def _icmp_ping(self, host: str) -> bool:
        """Realiza ping ICMP a un host"""
        try:
            # Crear paquete ICMP
            packet = scapy.IP(dst=host)/scapy.ICMP()
            
            # Enviar paquete y esperar respuesta
            response = scapy.sr1(packet, timeout=1, verbose=0)
            
            return response is not None
        except:
            return False
    
    def _tcp_ping(self, host: str) -> bool:
        """Realiza ping TCP a un host"""
        try:
            # Intentar conexión TCP a puertos comunes
            common_ports = [80, 443, 22, 21]
            for port in common_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((host, port))
                sock.close()
                if result == 0:
                    return True
        except:
            pass
        return False
    
    def _udp_ping(self, host: str) -> bool:
        """Realiza ping UDP a un host"""
        try:
            # Crear paquete UDP
            packet = scapy.IP(dst=host)/scapy.UDP(dport=53)
            
            # Enviar paquete y esperar respuesta
            response = scapy.sr1(packet, timeout=1, verbose=0)
            
            return response is not None
        except:
            return False
    
    def _scan_ports(self, host: str, ports: List[int], methods: List[str]) -> Dict:
        """Escanea puertos en un host usando diferentes métodos"""
        results = {}
        
        try:
            for port in ports:
                for method in methods:
                    if method == "tcp_connect":
                        service = self._tcp_connect_scan(host, port)
                        if service:
                            results[port] = service
                            break
                    elif method == "tcp_syn":
                        service = self._tcp_syn_scan(host, port)
                        if service:
                            results[port] = service
                            break
                    elif method == "udp_scan":
                        service = self._udp_scan(host, port)
                        if service:
                            results[port] = service
                            break
        
        except Exception as e:
            logger.error(f"Error al escanear puertos en {host}: {str(e)}")
        
        return results
    
    def _tcp_connect_scan(self, host: str, port: int) -> Dict:
        """Realiza escaneo TCP connect a un puerto"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            sock.close()
            
            if result == 0:
                return {
                    "state": "open",
                    "protocol": "tcp",
                    "service": self._get_service_name(port)
                }
        except:
            pass
        return None
    
    def _tcp_syn_scan(self, host: str, port: int) -> Dict:
        """Realiza escaneo TCP SYN a un puerto"""
        try:
            # Crear paquete SYN
            packet = scapy.IP(dst=host)/scapy.TCP(dport=port, flags="S")
            
            # Enviar paquete y esperar respuesta
            response = scapy.sr1(packet, timeout=1, verbose=0)
            
            if response and response.haslayer(scapy.TCP):
                if response[scapy.TCP].flags == 0x12:  # SYN-ACK
                    # Enviar RST para cerrar la conexión
                    rst_packet = scapy.IP(dst=host)/scapy.TCP(dport=port, flags="R")
                    scapy.send(rst_packet, verbose=0)
                    
                    return {
                        "state": "open",
                        "protocol": "tcp",
                        "service": self._get_service_name(port)
                    }
        except:
            pass
        return None
    
    def _udp_scan(self, host: str, port: int) -> Dict:
        """Realiza escaneo UDP a un puerto"""
        try:
            # Crear paquete UDP
            packet = scapy.IP(dst=host)/scapy.UDP(dport=port)
            
            # Enviar paquete y esperar respuesta
            response = scapy.sr1(packet, timeout=1, verbose=0)
            
            if response is None:
                return {
                    "state": "open|filtered",
                    "protocol": "udp",
                    "service": self._get_service_name(port)
                }
            elif response.haslayer(scapy.ICMP):
                if int(response[scapy.ICMP].type) == 3 and int(response[scapy.ICMP].code) == 3:
                    return {
                        "state": "closed",
                        "protocol": "udp",
                        "service": self._get_service_name(port)
                    }
        except:
            pass
        return None
    
    def _get_service_name(self, port: int) -> str:
        """Obtiene el nombre del servicio para un puerto"""
        try:
            return socket.getservbyport(port)
        except:
            return "unknown" 