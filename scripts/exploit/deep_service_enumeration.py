#!/usr/bin/env python3

import logging
import json
import os
import nmap
import ftplib
import paramiko
import requests
import ldap3
import pysnmp
import dns.resolver
from typing import Dict, List
from pymetasploit3.msfrpc import MsfRpcClient

logger = logging.getLogger(__name__)

class DeepServiceEnumeration:
    def __init__(self, msf_client: MsfRpcClient, config: Dict):
        """Inicializa el módulo de enumeración profunda de servicios"""
        self.msf_client = msf_client
        self.config = config
        self.temp_dir = os.path.join(os.path.dirname(__file__), "..", "..", "temp")
        os.makedirs(self.temp_dir, exist_ok=True)
        
        # Inicializar scanner nmap
        self.nm = nmap.PortScanner()
    
    def enumerate_services(self, target: str, ports_file: str = None) -> Dict:
        """Realiza enumeración profunda de servicios"""
        results = {
            "ftp": {},
            "ssh": {},
            "web": {},
            "smb": {},
            "ldap": {},
            "snmp": {},
            "dns": {}
        }
        
        try:
            # Cargar puertos si se proporciona archivo
            ports = self._load_ports(ports_file) if ports_file else self._scan_ports(target)
            
            # Enumerar cada servicio detectado
            for port in ports:
                service = ports[port].get("name", "").lower()
                
                if "ftp" in service:
                    results["ftp"] = self._enumerate_ftp(target, port)
                
                elif "ssh" in service:
                    results["ssh"] = self._enumerate_ssh(target, port)
                
                elif "http" in service or "https" in service:
                    results["web"] = self._enumerate_web(target, port)
                
                elif "smb" in service or "microsoft-ds" in service:
                    results["smb"] = self._enumerate_smb(target, port)
                
                elif "ldap" in service:
                    results["ldap"] = self._enumerate_ldap(target, port)
                
                elif "snmp" in service:
                    results["snmp"] = self._enumerate_snmp(target, port)
                
                elif "domain" in service:
                    results["dns"] = self._enumerate_dns(target, port)
        
        except Exception as e:
            logger.error(f"Error en enumeración profunda: {str(e)}")
        
        return results
    
    def _load_ports(self, ports_file: str) -> Dict:
        """Carga puertos desde archivo JSON"""
        try:
            with open(ports_file, 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error al cargar puertos: {str(e)}")
            return {}
    
    def _scan_ports(self, target: str) -> Dict:
        """Escanea puertos del objetivo"""
        try:
            self.nm.scan(target, arguments='-sS -sV -p-')
            return self.nm[target].all_ports()
        except Exception as e:
            logger.error(f"Error al escanear puertos: {str(e)}")
            return {}
    
    def _enumerate_ftp(self, target: str, port: int) -> Dict:
        """Enumera servicio FTP"""
        results = {
            "anonymous_access": False,
            "bounce_attack": False,
            "version": "",
            "banner": ""
        }
        
        try:
            # Probar acceso anónimo
            ftp = ftplib.FTP()
            ftp.connect(target, port)
            try:
                ftp.login()
                results["anonymous_access"] = True
                results["banner"] = ftp.getwelcome()
            except:
                pass
            
            # Verificar bounce attack
            try:
                ftp.sendcmd('PORT 127,0,0,1,0,80')
                results["bounce_attack"] = True
            except:
                pass
            
            ftp.quit()
        
        except Exception as e:
            logger.error(f"Error al enumerar FTP: {str(e)}")
        
        return results
    
    def _enumerate_ssh(self, target: str, port: int) -> Dict:
        """Enumera servicio SSH"""
        results = {
            "version": "",
            "auth_methods": [],
            "key_exchange": [],
            "encryption": [],
            "mac": []
        }
        
        try:
            # Conectar y obtener información
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(target, port, timeout=5)
            
            # Obtener información de la conexión
            transport = ssh.get_transport()
            if transport:
                results["version"] = transport.remote_version
                results["auth_methods"] = transport.auth_methods
                results["key_exchange"] = transport.kex
                results["encryption"] = transport.ciphers
                results["mac"] = transport.mac
            
            ssh.close()
        
        except Exception as e:
            logger.error(f"Error al enumerar SSH: {str(e)}")
        
        return results
    
    def _enumerate_web(self, target: str, port: int) -> Dict:
        """Enumera servicio web"""
        results = {
            "server": "",
            "technologies": [],
            "directories": [],
            "vulnerabilities": []
        }
        
        try:
            # Determinar protocolo
            protocol = "https" if port == 443 else "http"
            url = f"{protocol}://{target}:{port}"
            
            # Obtener información básica
            response = requests.get(url, verify=False, timeout=5)
            results["server"] = response.headers.get("Server", "")
            
            # Detectar tecnologías
            if "X-Powered-By" in response.headers:
                results["technologies"].append(response.headers["X-Powered-By"])
            
            # Buscar directorios comunes
            common_dirs = ["/admin", "/login", "/wp-admin", "/phpmyadmin", "/backup"]
            for dir in common_dirs:
                try:
                    r = requests.get(url + dir, verify=False, timeout=2)
                    if r.status_code < 400:
                        results["directories"].append(dir)
                except:
                    pass
        
        except Exception as e:
            logger.error(f"Error al enumerar web: {str(e)}")
        
        return results
    
    def _enumerate_smb(self, target: str, port: int) -> Dict:
        """Enumera servicio SMB"""
        results = {
            "null_sessions": False,
            "shares": [],
            "version": "",
            "os": ""
        }
        
        try:
            if not self.msf_client:
                return results
            
            # Usar módulo de Metasploit para enumeración SMB
            smb_module = self.msf_client.modules.use('auxiliary', 'scanner/smb/smb_version')
            smb_module['RHOSTS'] = target
            result = smb_module.execute()
            
            if result and "version" in result:
                results["version"] = result["version"]
                results["os"] = result.get("os", "")
            
            # Probar sesiones nulas
            null_module = self.msf_client.modules.use('auxiliary', 'scanner/smb/smb_enumshares')
            null_module['RHOSTS'] = target
            null_module['SMBUser'] = ''
            null_module['SMBPass'] = ''
            result = null_module.execute()
            
            if result and "shares" in result:
                results["null_sessions"] = True
                results["shares"] = result["shares"]
        
        except Exception as e:
            logger.error(f"Error al enumerar SMB: {str(e)}")
        
        return results
    
    def _enumerate_ldap(self, target: str, port: int) -> Dict:
        """Enumera servicio LDAP"""
        results = {
            "objects": [],
            "users": [],
            "groups": [],
            "computers": []
        }
        
        try:
            # Conectar a LDAP
            server = ldap3.Server(target, port=port, get_info=ldap3.ALL)
            conn = ldap3.Connection(server)
            
            if conn.bind():
                # Buscar objetos
                conn.search('dc=domain,dc=local', '(objectClass=*)', 
                          attributes=['cn', 'objectClass'])
                
                for entry in conn.entries:
                    results["objects"].append(str(entry))
                    
                    # Clasificar objetos
                    if 'user' in str(entry).lower():
                        results["users"].append(str(entry))
                    elif 'group' in str(entry).lower():
                        results["groups"].append(str(entry))
                    elif 'computer' in str(entry).lower():
                        results["computers"].append(str(entry))
        
        except Exception as e:
            logger.error(f"Error al enumerar LDAP: {str(e)}")
        
        return results
    
    def _enumerate_snmp(self, target: str, port: int) -> Dict:
        """Enumera servicio SNMP"""
        results = {
            "community_strings": [],
            "system_info": {},
            "interfaces": []
        }
        
        try:
            # Probar community strings comunes
            common_strings = ['public', 'private', 'community']
            
            for community in common_strings:
                try:
                    # Obtener información del sistema
                    cmd_gen = pysnmp.hlapi.asyncio.cmdgen.CommandGenerator()
                    error_indication, error_status, error_index, var_binds = cmd_gen.getCmd(
                        pysnmp.hlapi.asyncio.CommunityData(community),
                        pysnmp.hlapi.asyncio.UdpTransportTarget((target, port)),
                        pysnmp.hlapi.asyncio.ObjectType(pysnmp.hlapi.asyncio.ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0))
                    )
                    
                    if not error_indication and not error_status:
                        results["community_strings"].append(community)
                        results["system_info"] = str(var_binds)
                
                except:
                    pass
        
        except Exception as e:
            logger.error(f"Error al enumerar SNMP: {str(e)}")
        
        return results
    
    def _enumerate_dns(self, target: str, port: int) -> Dict:
        """Enumera servicio DNS"""
        results = {
            "zone_transfer": False,
            "records": [],
            "servers": []
        }
        
        try:
            # Configurar resolver
            resolver = dns.resolver.Resolver()
            resolver.nameservers = [target]
            
            # Intentar transferencia de zona
            try:
                zone = dns.zone.from_xfr(dns.query.xfr(target, 'domain.local'))
                results["zone_transfer"] = True
                for name, node in zone.nodes.items():
                    results["records"].append(str(name))
            except:
                pass
            
            # Obtener servidores DNS
            try:
                ns_records = resolver.resolve('domain.local', 'NS')
                for ns in ns_records:
                    results["servers"].append(str(ns))
            except:
                pass
        
        except Exception as e:
            logger.error(f"Error al enumerar DNS: {str(e)}")
        
        return results 