#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Módulo de integración con ExploitDB para el sistema de explotación
Incluye filtrado inteligente por versión específica
"""

import subprocess
import json
import logging
import os
import argparse
import re
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path

# Configuración de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class ExploitInfo:
    """Clase para almacenar información de un exploit"""
    id: str
    description: str
    path: str
    platform: str
    type: str
    port: Optional[int] = None
    service: Optional[str] = None
    version_match_score: Optional[float] = None  # Score de coincidencia de versión (0-1)

class VersionMatcher:
    """Clase para matching inteligente de versiones"""
    
    @staticmethod
    def extract_version_from_description(description: str) -> List[str]:
        """
        Extrae versiones del título/descripción del exploit
        
        Args:
            description: Descripción del exploit
            
        Returns:
            Lista de versiones encontradas
        """
        # Patrones comunes de versión
        version_patterns = [
            r'\b(\d+\.\d+(?:\.\d+)?(?:\.\d+)?)\b',  # X.Y.Z.W
            r'\b(\d+\.\d+(?:\.\d+)?)\b',            # X.Y.Z
            r'\b(\d+\.\d+)\b',                      # X.Y
            r'\bv(\d+\.\d+(?:\.\d+)?)\b',           # vX.Y.Z
            r'\bversion\s+(\d+\.\d+(?:\.\d+)?)\b',  # version X.Y.Z
            r'\b(\d{4})\b',                         # Años como versiones
        ]
        
        versions = []
        for pattern in version_patterns:
            matches = re.findall(pattern, description.lower())
            versions.extend(matches)
            
        return list(set(versions))  # Eliminar duplicados
    
    @staticmethod
    def version_similarity(target_version: str, exploit_version: str) -> float:
        """
        Calcula la similitud entre dos versiones
        
        Args:
            target_version: Versión del servicio objetivo
            exploit_version: Versión del exploit
            
        Returns:
            Score de similitud (0-1)
        """
        if not target_version or not exploit_version:
            return 0.0
            
        try:
            # Normalizar versiones
            target_parts = [int(x) for x in target_version.split('.')]
            exploit_parts = [int(x) for x in exploit_version.split('.')]
            
            # Igualar longitud de arrays
            max_len = max(len(target_parts), len(exploit_parts))
            target_parts.extend([0] * (max_len - len(target_parts)))
            exploit_parts.extend([0] * (max_len - len(exploit_parts)))
            
            # Calcular similitud
            if target_parts == exploit_parts:
                return 1.0  # Coincidencia exacta
            
            # Coincidencia parcial (major.minor coinciden)
            if len(target_parts) >= 2 and len(exploit_parts) >= 2:
                if target_parts[0] == exploit_parts[0] and target_parts[1] == exploit_parts[1]:
                    return 0.8  # Misma versión major.minor
                elif target_parts[0] == exploit_parts[0]:
                    return 0.6  # Misma versión major
            
            # Verificar si la versión objetivo está en rango vulnerable
            if target_parts[0] == exploit_parts[0]:
                # Misma versión major, verificar si minor es menor o igual
                if len(target_parts) >= 2 and len(exploit_parts) >= 2:
                    if target_parts[1] <= exploit_parts[1]:
                        return 0.4  # Potencialmente vulnerable
                        
            return 0.1  # Muy poca similitud
            
        except (ValueError, IndexError):
            # Fallback para versiones no numéricas
            if target_version.lower() in exploit_version.lower():
                return 0.5
            elif exploit_version.lower() in target_version.lower():
                return 0.5
            return 0.0
    
    @staticmethod
    def is_version_vulnerable(target_version: str, exploit_description: str, exploit_content: str = "") -> Tuple[bool, float]:
        """
        Determina si una versión específica es vulnerable según la descripción y contenido del exploit
        
        Args:
            target_version: Versión del servicio objetivo
            exploit_description: Descripción del exploit
            exploit_content: Contenido del exploit (opcional)
            
        Returns:
            Tupla (es_vulnerable, confidence_score)
        """
        if not target_version:
            return True, 0.3  # Sin versión específica, asumir potencialmente vulnerable
            
        # Combinar descripción y contenido para buscar versiones
        full_text = exploit_description or ""
        if exploit_content and len(exploit_content) < 5000:  # Evitar contenido muy largo
            full_text += " " + exploit_content[:2000]  # Solo los primeros 2000 caracteres
            
        # Extraer versiones del texto combinado
        exploit_versions = VersionMatcher.extract_version_from_description(full_text)
        
        if not exploit_versions:
            # Si no hay versiones específicas, usar criterios más permisivos
            if exploit_description or exploit_content:
                return True, 0.3  # Hay contenido pero sin versiones específicas
            else:
                return True, 0.2  # Sin información específica
                
        best_score = 0.0
        for exploit_version in exploit_versions:
            score = VersionMatcher.version_similarity(target_version, exploit_version)
            best_score = max(best_score, score)
            
        # Usar threshold más estricto cuando tenemos versión específica y exploits con versiones
        if exploit_versions and target_version:
            threshold = 0.6  # Más estricto para coincidencias con versiones específicas
        else:
            threshold = 0.3  # Más permisivo para casos sin versiones específicas
            
        is_vulnerable = best_score >= threshold
        return is_vulnerable, best_score

class ExploitDBManager:
    """Gestor de integración con ExploitDB"""
    
    def __init__(self, evidence_dir: str = "evidence", enable_version_filtering: bool = True, 
                 max_exploits_per_service: int = 20, compact_output: bool = True):
        """
        Inicializa el gestor de ExploitDB
        
        Args:
            evidence_dir: Directorio donde se guardarán las evidencias
            enable_version_filtering: Habilitar filtrado por versión específica
            max_exploits_per_service: Máximo número de exploits por servicio
            compact_output: Usar salida compacta para reducir tamaño
        """
        self.evidence_dir = Path(evidence_dir)
        self.exploitdb_path = Path("/usr/share/exploitdb")
        self.enable_version_filtering = enable_version_filtering
        self.max_exploits_per_service = max_exploits_per_service
        self.compact_output = compact_output
        self.version_matcher = VersionMatcher()
        
        # Verificar que ExploitDB está instalado
        if not self.exploitdb_path.exists():
            raise FileNotFoundError("ExploitDB no encontrado en /usr/share/exploitdb")
            
        # Crear directorio de evidencias si no existe
        self.evidence_dir.mkdir(parents=True, exist_ok=True)
        
    def extract_search_terms(self, service_name: str) -> List[str]:
        """
        Extrae términos de búsqueda efectivos del nombre del servicio
        
        Args:
            service_name: Nombre completo del servicio
            
        Returns:
            Lista de términos de búsqueda
        """
        # Normalizar y limpiar
        service_lower = service_name.lower()
        
        # Mapeo de servicios comunes - MEJORADO
        service_mappings = {
            'iis': ['iis', 'microsoft iis'],  # Captura cualquier mención de IIS
            'microsoft iis': ['iis', 'microsoft iis'],
            'iis httpd': ['iis', 'microsoft iis'],
            'http microsoft iis': ['iis', 'microsoft iis'],  # Para "http Microsoft IIS httpd"
            'apache httpd': ['apache', 'httpd'],
            'apache': ['apache', 'httpd'],
            'microsoft windows rpc': ['rpc', 'windows rpc', 'microsoft rpc'],
            'msrpc': ['rpc', 'microsoft rpc', 'windows rpc'],
            'rpc': ['rpc', 'microsoft rpc'],
            'microsoft-ds': ['smb', 'samba', 'windows smb', 'microsoft-ds'],
            'netbios-ssn': ['netbios', 'smb', 'netbios-ssn'],
            'netbios': ['netbios', 'smb'],
            'microsoft windows netbios': ['netbios', 'smb', 'windows'],
            'smb': ['smb', 'samba', 'microsoft-ds'],
            'mysql': ['mysql'],
            'postgresql': ['postgresql', 'postgres'],
            'ssh': ['ssh', 'openssh'],
            'openssh': ['ssh', 'openssh'],
            'ftp': ['ftp'],
            'telnet': ['telnet'],
            'smtp': ['smtp'],
            'pop3': ['pop3'],
            'imap': ['imap'],
            'dns': ['dns', 'bind'],
            'dhcp': ['dhcp'],
            'ssl': ['ssl', 'tls'],
            'https': ['https', 'ssl', 'tls'],
            'websocket': ['websocket'],
            'tcpwrapped': []  # Skip tcpwrapped services
        }
        
        # Buscar mapeos directos - MEJORADO para ser más flexible
        for pattern, terms in service_mappings.items():
            if pattern in service_lower:
                if terms:  # Si hay términos mapeados
                    logger.debug(f"Mapeo encontrado para '{pattern}' en '{service_name}': {terms}")
                    return terms
                else:  # Si está en la lista de skip
                    return []
        
        # Extraer palabras clave comunes - MEJORADO
        keywords = []
        
        # Buscar nombres de productos conocidos con mayor precisión
        products = {
            'iis': ['iis', 'microsoft iis'],
            'apache': ['apache', 'httpd'],
            'nginx': ['nginx'],
            'mysql': ['mysql'],
            'postgresql': ['postgresql', 'postgres'],
            'ssh': ['ssh', 'openssh'],
            'ftp': ['ftp'],
            'smtp': ['smtp'],
            'pop3': ['pop3'],
            'imap': ['imap'],
            'dns': ['dns', 'bind'],
            'dhcp': ['dhcp'],
            'samba': ['smb', 'samba'],
            'bind': ['dns', 'bind'],
            'postfix': ['smtp', 'postfix'],
            'rpc': ['rpc', 'microsoft rpc'],
            'smb': ['smb', 'samba'],
            'netbios': ['netbios', 'smb']
        }
        
        for product, search_terms in products.items():
            if product in service_lower:
                logger.debug(f"Producto encontrado '{product}' en '{service_name}': {search_terms}")
                return search_terms
        
        # Buscar sistemas operativos
        os_keywords = []
        if 'windows' in service_lower:
            os_keywords.append('windows')
        if 'linux' in service_lower:
            os_keywords.append('linux')
            
        # Si no se encontraron keywords específicas, usar el primer término útil
        if not keywords and not os_keywords:
            words = service_lower.split()
            if words:
                # Filtrar palabras comunes no útiles
                stop_words = {'microsoft', 'httpd', 'service', 'daemon', 'server', 
                             'version', 'protocol', 'the', 'and', 'or', 'in', 'on', 'http', 'https'}
                useful_words = [w for w in words if w not in stop_words and len(w) > 2]
                if useful_words:
                    # Priorizar palabras conocidas
                    for word in useful_words:
                        if word in products:
                            return products[word]
                    # Si no hay palabras conocidas, usar la primera útil
                    keywords.append(useful_words[0])
        
        # Combinar keywords encontradas
        final_keywords = keywords + os_keywords
        if final_keywords:
            logger.debug(f"Keywords extraídas de '{service_name}': {final_keywords}")
            return final_keywords
        
        # Fallback: usar el primer término no vacío
        words = service_lower.split()
        if words:
            logger.warning(f"Usando fallback para '{service_name}': [{words[0]}]")
            return [words[0]]
        
        logger.warning(f"No se pudieron extraer términos de búsqueda para: {service_name}")
        return []

    def _create_compact_exploit_summary(self, exploit: ExploitInfo) -> Dict:
        """
        Crea un resumen compacto del exploit para reducir el tamaño de salida
        
        Args:
            exploit: Información del exploit
            
        Returns:
            Diccionario con información compacta del exploit
        """
        if self.compact_output:
            # Truncar descripción larga
            description = exploit.description
            if len(description) > 150:
                description = description[:147] + "..."
                
            return {
                "id": exploit.id,
                "desc": description,  # Nombre más corto
                "path": exploit.path,
                "platform": exploit.platform[:10] if exploit.platform else None,  # Truncar plataforma
                "type": exploit.type[:15] if exploit.type else None,  # Truncar tipo
                "port": exploit.port,
                "score": round(exploit.version_match_score, 2) if exploit.version_match_score else None
            }
        else:
            return {
                "id": exploit.id,
                "description": exploit.description,
                "path": exploit.path,
                "platform": exploit.platform,
                "type": exploit.type,
                "service": exploit.service,
                "port": exploit.port,
                "version_match_score": exploit.version_match_score
            }

    def search_exploits(self, service: str, version: Optional[str] = None) -> List[ExploitInfo]:
        """
        Busca exploits para un servicio específico con optimizaciones
        
        Args:
            service: Nombre del servicio
            version: Versión específica del servicio (opcional)
            
        Returns:
            Lista de exploits encontrados (limitada)
        """
        try:
            logger.info(f"Buscando exploits para {service} {version or 'sin versión específica'}")
            
            # Extraer términos de búsqueda
            search_terms = self.extract_search_terms(service)
            all_exploits = []
            
            # Buscar con cada término
            for term in search_terms[:3]:  # Limitar a 3 términos principales
                try:
                    # Generar consultas específicas por versión si está disponible
                    if version and self.enable_version_filtering:
                        version_queries = self._generate_version_specific_queries(term, version)
                        for query in version_queries[:2]:  # Máximo 2 consultas por versión
                            exploits = self._search_exploits_by_query(query, service)
                            all_exploits.extend(exploits)
                            
                            # Parar si ya tenemos suficientes exploits
                            if len(all_exploits) >= self.max_exploits_per_service:
                                break
                    
                    # Si no tenemos suficientes exploits, buscar de forma general
                    if len(all_exploits) < self._get_minimum_exploits_threshold(term):
                        general_exploits = self._search_exploits_by_query(term, service)
                        all_exploits.extend(general_exploits)
                        
                except Exception as e:
                    logger.error(f"Error buscando con término '{term}': {str(e)}")
                    continue
                    
                # Parar si ya tenemos suficientes exploits
                if len(all_exploits) >= self.max_exploits_per_service:
                    break
            
            # Eliminar duplicados por ID
            unique_exploits = {}
            for exploit in all_exploits:
                if exploit.id not in unique_exploits:
                    unique_exploits[exploit.id] = exploit
            
            exploits_list = list(unique_exploits.values())
            
            # Filtrar por versión si está habilitado
            if version and self.enable_version_filtering and exploits_list:
                exploits_list = self._filter_exploits_by_version(exploits_list, version)
            
            # Ordenar por score de versión (mayor primero) y limitar resultados
            exploits_list.sort(key=lambda x: x.version_match_score or 0, reverse=True)
            exploits_list = exploits_list[:self.max_exploits_per_service]
            
            logger.info(f"Encontrados {len(exploits_list)} exploits únicos para {service}")
            return exploits_list
            
        except Exception as e:
            logger.error(f"Error en search_exploits: {str(e)}")
            return []
    
    def _generate_version_specific_queries(self, service_term: str, version: str) -> List[str]:
        """
        Genera consultas de búsqueda específicas combinando servicio y versión
        
        Args:
            service_term: Término del servicio (ej: 'iis', 'apache')
            version: Versión específica (ej: '7.5', '2.4.41')
            
        Returns:
            Lista de consultas optimizadas
        """
        queries = []
        
        # 1. Búsqueda exacta: "servicio versión"
        queries.append(f"{service_term} {version}")
        
        # 2. Para versiones con puntos, probar variaciones
        if '.' in version:
            parts = version.split('.')
            
            # Versión major.minor (ej: "iis 7.5" para "7.5.1")
            if len(parts) >= 2:
                major_minor = f"{parts[0]}.{parts[1]}"
                if major_minor != version:  # Evitar duplicado
                    queries.append(f"{service_term} {major_minor}")
            
            # Solo versión major (ej: "iis 7" para "7.5")
            queries.append(f"{service_term} {parts[0]}")
            
            # Variaciones con espacios (ej: "iis 7 5" para "7.5")
            version_spaced = version.replace('.', ' ')
            queries.append(f"{service_term} {version_spaced}")
        
        # 3. Búsquedas con palabras clave comunes
        version_keywords = [
            f"{service_term} version {version}",
            f"{service_term} v{version}",
            f"{service_term}{version}",  # Sin espacio
        ]
        queries.extend(version_keywords)
        
        # 4. Para servicios específicos, agregar variaciones conocidas
        if service_term.lower() in ['iis', 'microsoft iis']:
            queries.extend([
                f"microsoft iis {version}",
                f"windows iis {version}",
                f"iis httpd {version}",
            ])
        elif service_term.lower() in ['apache']:
            queries.extend([
                f"apache httpd {version}",
                f"apache http server {version}",
                f"apache {version}",
            ])
        elif service_term.lower() in ['mysql']:
            queries.extend([
                f"mysql server {version}",
                f"mysql database {version}",
            ])
        
        # Eliminar duplicados manteniendo el orden
        unique_queries = []
        for query in queries:
            if query not in unique_queries:
                unique_queries.append(query)
                
        return unique_queries
    
    def _search_exploits_by_query(self, search_query: str, service: str) -> List[ExploitInfo]:
        """
        Ejecuta una búsqueda específica en ExploitDB
        
        Args:
            search_query: Consulta de búsqueda
            service: Nombre del servicio
            
        Returns:
            Lista de exploits encontrados
        """
        exploits = []
        
        try:
            # Comando con timeout para evitar búsquedas muy largas
            cmd = ["timeout", "30", "searchsploit", "-j", search_query]
            logger.info(f"Buscando exploits para: {search_query}")
            
            # Ejecutar búsqueda con timeout
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=35)
            
            if result.returncode != 0:
                if result.returncode == 124:  # Timeout
                    logger.warning(f"Búsqueda timeout para: {search_query}")
                else:
                    logger.error(f"Error en búsqueda: {result.stderr}")
                return exploits
                
            # Verificar tamaño de salida para evitar JSON muy grandes
            if len(result.stdout) > 1048576:  # 1MB limit
                logger.warning(f"Salida muy grande para '{search_query}', truncando...")
                result.stdout = result.stdout[:1048576]
                
            # Procesar resultados
            try:
                data = json.loads(result.stdout)
                
                exploit_results = data.get("RESULTS_EXPLOIT", [])
                # Limitar número de resultados procesados
                exploit_results = exploit_results[:50]  # Máximo 50 por consulta
                
                for exploit in exploit_results:
                    # Extraer información relevante
                    path = exploit.get("Path", "")
                    if not path:
                        continue
                        
                    # CRITICAL FIX: Mejorar extracción de descripción
                    description = exploit.get("Description", "").strip()
                    
                    # Si la descripción está vacía, intentar extraer del título o path
                    if not description:
                        # Intentar extraer del título si existe
                        title = exploit.get("Title", "").strip()
                        if title:
                            description = title
                        else:
                            # Fallback: extraer del nombre del archivo
                            filename = os.path.basename(path)
                            if filename:
                                # Remover extensión y números de ID
                                description = re.sub(r'^\d+\.', '', filename)  # Remover ID inicial
                                description = re.sub(r'\.[^.]+$', '', description)  # Remover extensión
                                description = description.replace('_', ' ').replace('-', ' ')
                                description = ' '.join(description.split())  # Normalizar espacios
                                if description:
                                    description = f"Exploit: {description}"
                    
                    # Si aún no hay descripción, usar información del servicio
                    if not description:
                        description = f"Exploit for {service} service"
                    
                    # Normalizar ruta para extraer plataforma y tipo correctamente
                    normalized_path = path
                    if path.startswith("/usr/share/exploitdb/"):
                        normalized_path = path[len("/usr/share/exploitdb/"):]
                    elif path.startswith("/"):
                        # Otras rutas absolutas, buscar "exploits/"
                        if "exploits/" in path:
                            normalized_path = path[path.find("exploits/"):]
                    
                    # Determinar tipo y plataforma
                    parts = normalized_path.split("/")
                    if len(parts) < 3:
                        continue
                        
                    platform = parts[1] if parts[0] == "exploits" else "unknown"
                    type_ = parts[2] if len(parts) > 2 else "unknown"
                    
                    # Crear objeto ExploitInfo
                    exploit_info = ExploitInfo(
                        id=exploit.get("EDB-ID", ""),
                        description=description,  # FIXED: Usar descripción mejorada
                        path=path,
                        platform=platform,
                        type=type_,
                        service=service
                    )
                    
                    exploits.append(exploit_info)
                    
            except json.JSONDecodeError as e:
                logger.error(f"Error decodificando JSON de searchsploit: {str(e)}")
                
        except subprocess.TimeoutExpired:
            logger.warning(f"Timeout en búsqueda de exploits para: {search_query}")
        except Exception as e:
            logger.error(f"Error en _search_exploits_by_query: {str(e)}")
            
        logger.info(f"Encontrados {len(exploits)} exploits para '{search_query}'")
        return exploits
    
    def _filter_exploits_by_version(self, exploits: List[ExploitInfo], target_version: str) -> List[ExploitInfo]:
        """
        Filtra exploits basándose en la versión específica del servicio
        
        Args:
            exploits: Lista de exploits a filtrar
            target_version: Versión específica del servicio objetivo
            
        Returns:
            Lista filtrada de exploits relevantes para la versión
        """
        relevant_exploits = []
        
        for exploit in exploits:
            # Obtener contenido del exploit para análisis de versión
            exploit_content = self.get_exploit_content(exploit.path) or ""
            
            is_vulnerable, confidence = self.version_matcher.is_version_vulnerable(
                target_version, exploit.description, exploit_content
            )
            
            if is_vulnerable:
                exploit.version_match_score = confidence
                relevant_exploits.append(exploit)
                logger.debug(f"Exploit {exploit.id} relevante para v{target_version} (score: {confidence:.2f}): {exploit.description[:80]}...")
            else:
                logger.debug(f"Exploit {exploit.id} NO relevante para v{target_version} (score: {confidence:.2f}): {exploit.description[:80]}...")
        
        # Ordenar por puntuación de relevancia (mayor a menor)
        relevant_exploits.sort(key=lambda x: x.version_match_score or 0, reverse=True)
        
        return relevant_exploits
        
    def get_exploit_content(self, exploit_path: str) -> Optional[str]:
        """
        Obtiene el contenido de un exploit específico
        
        Args:
            exploit_path: Ruta relativa del exploit en ExploitDB
            
        Returns:
            Contenido del exploit o None si hay error
        """
        try:
            full_path = self.exploitdb_path / exploit_path
            if not full_path.exists():
                logger.error(f"Exploit no encontrado: {full_path}")
                return None
                
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                return f.read()
                
        except Exception as e:
            logger.error(f"Error leyendo exploit {exploit_path}: {str(e)}")
            return None
            
    def save_exploit_evidence(self, target: str, exploits: List[ExploitInfo]) -> str:
        """
        Guarda la evidencia de los exploits encontrados
        
        Args:
            target: IP o hostname del objetivo
            exploits: Lista de exploits encontrados
            
        Returns:
            Ruta del archivo de evidencia
        """
        try:
            # Crear directorio para el objetivo
            target_dir = self.evidence_dir / target
            target_dir.mkdir(parents=True, exist_ok=True)
            
            # Preparar datos para guardar
            evidence = {
                "target": target,
                "timestamp": subprocess.check_output(["date", "+%Y%m%d_%H%M%S"]).decode().strip(),
                "version_filtering_enabled": self.enable_version_filtering,
                "exploits": []
            }
            
            for exploit in exploits:
                exploit_data = {
                    "id": exploit.id,
                    "description": exploit.description,
                    "path": exploit.path,
                    "platform": exploit.platform,
                    "type": exploit.type,
                    "service": exploit.service,
                    "port": exploit.port,
                    "version_match_score": exploit.version_match_score
                }
                
                # Obtener contenido del exploit
                content = self.get_exploit_content(exploit.path)
                if content:
                    exploit_data["content"] = content
                    
                evidence["exploits"].append(exploit_data)
                
            # Guardar evidencia
            evidence_file = target_dir / f"exploitdb_scan_{evidence['timestamp']}.json"
            with open(evidence_file, 'w') as f:
                json.dump(evidence, f, indent=2)
                
            logger.info(f"Evidencia guardada en: {evidence_file}")
            return str(evidence_file)
            
        except Exception as e:
            logger.error(f"Error guardando evidencia: {str(e)}")
            return ""
            
    def analyze_service(self, target: str, service: str, version: Optional[str] = None) -> Dict:
        """
        Analiza un servicio y busca exploits relevantes
        
        Args:
            target: IP o hostname del objetivo
            service: Nombre del servicio
            version: Versión específica del servicio
            
        Returns:
            Diccionario con resultados del análisis
        """
        try:
            # Buscar exploits con filtrado por versión
            exploits = self.search_exploits(service, version)
            
            # Guardar evidencia completa
            evidence_file = self.save_exploit_evidence(target, exploits)
            
            # Crear lista de exploits compacta para la salida JSON
            exploits_summary = [self._create_compact_exploit_summary(exploit) for exploit in exploits]
            
            return {
                "success": True,
                "target": target,
                "service": service,
                "version": version,
                "exploits_found": len(exploits),
                "version_filtering_enabled": self.enable_version_filtering,
                "evidence_file": evidence_file,
                "exploits": exploits_summary  # Salida compacta
            }
            
        except Exception as e:
            logger.error(f"Error en analyze_service: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
            
    def analyze_services_file(self, target: str, services_file: str) -> Dict:
        """
        Analiza múltiples servicios desde un archivo JSON
        
        Args:
            target: IP o hostname del objetivo
            services_file: Ruta al archivo JSON con servicios
            
        Returns:
            Diccionario con resultados del análisis
        """
        try:
            # Leer archivo de servicios
            with open(services_file, 'r') as f:
                services_data = json.load(f)
                
            all_exploits = []
            total_exploits = 0
            services_processed = 0
            max_services = 10  # Limitar número de servicios procesados
            max_exploits_per_service_balanced = 10  # Máximo por servicio para balance
            
            # Analizar cada servicio (limitado) - ESTRATEGIA BALANCEADA
            for service_key, service_info in list(services_data.items())[:max_services]:
                # Extraer nombre y versión del servicio
                service_name = service_info.get('service', service_info.get('service_name', ''))
                version = service_info.get('version', '')
                
                if not service_name:
                    continue
                    
                # Buscar exploits para el servicio
                service_exploits = self.search_exploits(service_name, version)
                
                # Limitar exploits por servicio para balance entre servicios
                service_exploits_limited = service_exploits[:max_exploits_per_service_balanced]
                total_exploits += len(service_exploits)  # Contar todos los encontrados
                services_processed += 1
                
                # Agregar información del puerto si está disponible
                for exploit in service_exploits_limited:
                    if 'port' in service_info:
                        exploit.port = service_info['port']
                    all_exploits.append(exploit)
                    
                logger.info(f"Servicio {service_name} (puerto {service_info.get('port', 'N/A')}): {len(service_exploits_limited)} exploits agregados de {len(service_exploits)} encontrados")
                    
            # Guardar evidencia combinada
            evidence_file = self.save_exploit_evidence(target, all_exploits)
            
            # Crear lista de exploits compacta para la salida JSON
            exploits_summary = [self._create_compact_exploit_summary(exploit) for exploit in all_exploits]
            
            return {
                "success": True,
                "target": target,
                "services_analyzed": services_processed,
                "total_services": len(services_data),
                "exploits_found": len(all_exploits),  # Exploits incluidos en la salida
                "total_exploits_discovered": total_exploits,  # Total encontrados
                "evidence_file": evidence_file,
                "exploits": exploits_summary,  # Salida compacta balanceada
                "note": f"Procesados {services_processed} de {len(services_data)} servicios. Incluidos {len(all_exploits)} exploits balanceados de {total_exploits} encontrados." if services_processed < len(services_data) else None
            }
            
        except Exception as e:
            logger.error(f"Error en analyze_services_file: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def _get_minimum_exploits_threshold(self, service_term: str) -> int:
        """
        Determina el número mínimo de exploits necesarios antes de hacer búsqueda general
        
        Args:
            service_term: Término del servicio
            
        Returns:
            Threshold mínimo de exploits
        """
        service_lower = service_term.lower()
        
        # Servicios con muchos exploits disponibles - threshold más alto
        if service_lower in ['apache', 'mysql', 'php', 'wordpress', 'joomla']:
            return 20
        
        # Servicios moderadamente populares - threshold medio
        elif service_lower in ['iis', 'microsoft iis', 'nginx', 'postgresql', 'ssh']:
            return 10
        
        # Servicios especializados - threshold bajo
        else:
            return 5

def main():
    """Función principal"""
    parser = argparse.ArgumentParser(description="Integración con ExploitDB")
    parser.add_argument("target", help="IP o hostname del objetivo")
    parser.add_argument("--service", help="Servicio a analizar")
    parser.add_argument("--version", help="Versión del servicio")
    parser.add_argument("--services", help="Archivo JSON con servicios a analizar")
    parser.add_argument("--output", help="Archivo de salida para los resultados")
    parser.add_argument("--debug", action="store_true", help="Activar modo debug")
    parser.add_argument("--no-version-filter", action="store_true", 
                       help="Desactivar filtrado por versión específica")
    parser.add_argument("--max-exploits", type=int, default=20,
                       help="Máximo número de exploits por servicio (default: 20)")
    parser.add_argument("--full-output", action="store_true",
                       help="Usar salida completa en lugar de compacta")
    
    args = parser.parse_args()
    
    if args.debug:
        logger.setLevel(logging.DEBUG)
        
    try:
        # Configurar parámetros
        enable_version_filtering = not args.no_version_filter
        compact_output = not args.full_output
        
        manager = ExploitDBManager(
            enable_version_filtering=enable_version_filtering,
            max_exploits_per_service=args.max_exploits,
            compact_output=compact_output
        )
        
        # Analizar servicios según los argumentos proporcionados
        if args.services:
            results = manager.analyze_services_file(args.target, args.services)
        elif args.service:
            results = manager.analyze_service(args.target, args.service, args.version)
        else:
            raise ValueError("Se requiere --service o --services")
            
        # Guardar resultados en archivo si se especificó
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
                
        # Imprimir resultados (compactos)
        if compact_output:
            # Salida ultra-compacta para stdout - INCLUIR TODOS LOS EXPLOITS
            compact_results = {
                "success": results["success"],
                "target": results["target"],
                "exploits_found": results["exploits_found"],
                "evidence_file": results.get("evidence_file", ""),
                "exploits": results.get("exploits", [])  # Incluir TODOS los exploits encontrados
            }
            print(json.dumps(compact_results))
        else:
            print(json.dumps(results, indent=2))
        
        return 0 if results["success"] else 1
        
    except Exception as e:
        error_result = {"success": False, "error": str(e)}
        print(json.dumps(error_result))
        return 1

if __name__ == "__main__":
    exit(main()) 