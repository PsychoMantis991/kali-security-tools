#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Script para ejecutar exploits individuales
"""

import json
import logging
import os
import subprocess
import sys
import argparse
from pathlib import Path
from typing import Dict, Optional

# Configuración de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ExploitExecutor:
    """Clase para ejecutar exploits individuales"""
    
    def __init__(self, target: str, evidence_dir: str = "evidence"):
        """
        Inicializa el ejecutor de exploits
        
        Args:
            target: IP o hostname del objetivo
            evidence_dir: Directorio donde se guardan las evidencias
        """
        self.target = target
        self.evidence_dir = Path(evidence_dir)
        self.results_dir = self.evidence_dir / target / "exploits"
        self.results_dir.mkdir(parents=True, exist_ok=True)
        
    def get_exploit_path(self, exploit_id: str) -> Optional[str]:
        """
        Obtiene la ruta del exploit en ExploitDB
        
        Args:
            exploit_id: ID del exploit
            
        Returns:
            Ruta del exploit o None si no se encuentra
        """
        try:
            # Buscar el exploit en ExploitDB
            cmd = ["searchsploit", "-j", exploit_id]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                logger.error(f"Error buscando exploit {exploit_id}: {result.stderr}")
                return None
                
            # Procesar resultados
            data = json.loads(result.stdout)
            for exploit in data.get("RESULTS_EXPLOIT", []):
                if exploit.get("EDB-ID") == exploit_id:
                    return exploit.get("Path")
                    
            return None
            
        except Exception as e:
            logger.error(f"Error en get_exploit_path: {str(e)}")
            return None
            
    def execute_exploit(self, exploit_id: str, output_file: Optional[str] = None) -> Dict:
        """
        Ejecuta un exploit específico
        
        Args:
            exploit_id: ID del exploit a ejecutar
            output_file: Archivo opcional para guardar la salida
            
        Returns:
            Diccionario con resultados de la ejecución
        """
        try:
            # Obtener ruta del exploit
            exploit_path = self.get_exploit_path(exploit_id)
            if not exploit_path:
                raise FileNotFoundError(f"Exploit {exploit_id} no encontrado")
                
            # Preparar comando de ejecución
            cmd = [
                "python3",
                f"/usr/share/exploitdb/{exploit_path}",
                self.target
            ]
            
            logger.info(f"Ejecutando exploit {exploit_id}...")
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            # Preparar resultados
            execution_result = {
                "target": self.target,
                "exploit_id": exploit_id,
                "timestamp": subprocess.check_output(["date", "+%Y%m%d_%H%M%S"]).decode().strip(),
                "success": result.returncode == 0,
                "output": result.stdout,
                "error": result.stderr if result.returncode != 0 else None
            }
            
            # Guardar resultados si se especificó archivo de salida
            if output_file:
                with open(output_file, 'w') as f:
                    json.dump(execution_result, f, indent=2)
                    
            return execution_result
            
        except Exception as e:
            logger.error(f"Error en execute_exploit: {str(e)}")
            return {
                "target": self.target,
                "exploit_id": exploit_id,
                "success": False,
                "error": str(e)
            }
            
def main():
    """Función principal"""
    parser = argparse.ArgumentParser(description="Ejecutor de exploits individuales")
    parser.add_argument("target", help="IP o hostname del objetivo")
    parser.add_argument("--exploit", required=True, help="ID del exploit a ejecutar")
    parser.add_argument("--output", help="Archivo de salida para los resultados")
    parser.add_argument("--debug", action="store_true", help="Activar modo debug")
    
    args = parser.parse_args()
    
    if args.debug:
        logger.setLevel(logging.DEBUG)
        
    try:
        executor = ExploitExecutor(args.target)
        result = executor.execute_exploit(args.exploit, args.output)
        
        # Imprimir resultados
        print(json.dumps(result, indent=2))
        
        return 0 if result["success"] else 1
        
    except Exception as e:
        print(f"Error: {str(e)}")
        return 1

if __name__ == "__main__":
    exit(main()) 